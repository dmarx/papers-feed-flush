---
File: .github/workflows/1_update_and_enrich.yml
---
name: 1) Process Updates + Enrichments

on:
  workflow_dispatch:
  issues:
    types: [reopened]
    
  schedule:
    - cron: '0 0 * * *'

jobs:
  hydrate-arxiv:
    runs-on: ubuntu-latest
    if: >
      contains(join(github.event.issue.labels.*.name, ','), 'TODO:hydrate-metadata') ||
      github.event_name == 'workflow_dispatch'
    permissions:
      issues: write
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          
      - name: Install dependencies
        run: pip install gh-store>=0.11.2 arxiv

      - name: Process Updates
        run: |
          python scripts/hydrate_metadata.py \
            hydrate_all_open_issues \
            --repo ${{ github.repository }} \
            --token ${{ secrets.GITHUB_TOKEN }}

  process-updates:
    runs-on: ubuntu-latest
    if: "!contains(github.event.issue.labels.*.name, 'TODO:hydrate-metadata') && contains(github.event.issue.labels.*.name, 'stored-object')"
    permissions:
      issues: write
    steps:
      - uses: actions/checkout@v4
      
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          
      - name: Install dependencies
        run: pip install gh-store>=0.11.2
          
      - name: Process Updates
        run: |
          python -m gh_store process-updates \
            --issue ${{ github.event.issue.number }} \
            --token ${{ secrets.GITHUB_TOKEN }} \
            --repo ${{ github.repository }}

  notify-deploy-after-process:
    needs: [process-updates]
    if: contains(join(github.event.issue.labels.*.name, ','), 'stored-object')
    runs-on: ubuntu-latest
    steps:
          
      - name: Trigger frontend deploy
        run: |
          curl -L \
            -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/2_deploy-frontend.yml/dispatches \
            -d "{\"ref\":\"${{ github.ref }}\"}"

  notify-deploy-after-enrichment:
    needs: [hydrate-arxiv]
    if: contains(join(github.event.issue.labels.*.name, ','), 'stored-object')
    runs-on: ubuntu-latest
    steps:
          
      - name: Trigger frontend deploy
        run: |
          curl -L \
            -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/${{ github.repository }}/actions/workflows/2_deploy-frontend.yml/dispatches \
            -d "{\"ref\":\"${{ github.ref }}\"}"



---
File: .github/workflows/2_deploy-frontend.yml
---
name: Deploy Frontend

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'data/papers/gh-store-snapshot.json'
      - 'frontend/*'
      - '.github/workflows/2_deploy-frontend.yml'

concurrency:
  group: store-deploy
  cancel-in-progress: false

permissions:
  contents: write
  pages: write
  id-token: write
  actions: read

jobs:
  update-snapshot:
    runs-on: ubuntu-latest
    outputs:
      changes_detected: ${{ steps.commit-changes.outputs.changes_detected }}
    steps:
      - name: Wait for updates
        uses: actions/github-script@v7
        with:
          script: |
            while (true) {
              const runs = await github.rest.actions.listWorkflowRuns({
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: '1_store-sync.yml',
              });
              
              const activeUpdates = runs.data.workflow_runs.filter(run => 
                (run.status === 'in_progress' || run.status === 'queued')
              );
              
              if (activeUpdates.length === 0) break;
              console.log(`Waiting for ${activeUpdates.length} active updates to complete...`);
              await new Promise(r => setTimeout(r, 10000));
            }

      - uses: actions/checkout@v4
      
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
          
      - name: Install dependencies
        run: pip install gh-store

      - name: Update snapshot
        env:
          SNAPSHOT_PATH: data/papers/gh-store-snapshot.json
        run: |
          mkdir -p $(dirname ${{ env.SNAPSHOT_PATH }})
          python -m gh_store update-snapshot \
            --token ${{ secrets.GITHUB_TOKEN }} \
            --repo ${{ github.repository }} \
            --snapshot-path ${{ env.SNAPSHOT_PATH }}
      
      # - name: Convert data
      #   run: |
      #     python frontend/scripts/convert_store.py \
      #       --snapshot_path data/papers/gh-store-snapshot.json \
      #       --output_path data/papers/papers.json \
      #       --archive_path data/papers/papers-archive.json \
      #       --features_base data/papers

      - name: Upload papers data
        uses: actions/upload-artifact@v4
        with:
          name: papers-json
          path: data/papers/gh-store-snapshot.json

      - name: Commit changes
        id: commit-changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: Update store snapshot [${{ github.run_id }}]"
          file_pattern: 'data/papers/**'
      
  deploy:
    needs: update-snapshot
    if: github.event_name == 'workflow_dispatch' || needs.update-snapshot.outputs.changes_detected == 'true'
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true

      - name: Download papers.json
        uses: actions/download-artifact@v4
        with:
          name: papers-json
          path: web/

      - name: Build web directory
        run: |
          cp frontend/* web/
          
          # Copy paper features maintaining directory structure
          cd data
          if [ -d "papers" ]; then
            # Create papers directory in web/data
            mkdir -p ../web/data/papers
            
            # Find all markdown files under papers/*/features
            # and copy them maintaining directory structure
            find papers -type f -name "*.md" -path "*/features/*" -exec cp --parents {} ../web/data/ \;
          fi
          cd ..

      - name: Get git info
        id: git-info
        run: |
          echo "branch=${GITHUB_REF#refs/heads/}" >> $GITHUB_OUTPUT
          echo "commit=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "repo=${GITHUB_REPOSITORY}" >> $GITHUB_OUTPUT

      - name: Create git info JSON
        run: |
          echo "{\"branch\": \"${{ steps.git-info.outputs.branch }}\", \"commit\": \"${{ steps.git-info.outputs.commit }}\", \"repo\": \"${{ steps.git-info.outputs.repo }}\"}" > web/data/git-info.json

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./web
          force_orphan: true



---
File: .github/workflows/build-extension.yml
---
# .github/workflows/build-extension.yml
name: Build Extension

on:
  push:
    paths:
      - 'extension/**'
      - '.github/workflows/build-extension.yml'
    branches: [ main, ext-use-gh-store ]
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: extension

    steps:
    - uses: actions/checkout@v4
    
    # Generate package-lock.json if it doesn't exist
    # - name: Initialize npm
    #   run: |
    #     if [ ! -f "package-lock.json" ]; then
    #       npm install --package-lock-only --no-audit
    #     else
    #       echo "package-lock.json exists"
    #     fi
    
    # Regenerate package-lock.json to ensure it matches package.json
    - name: Regenerate package-lock.json
      run: |
        if [ -f "package-lock.json" ]; then
          rm -f package-lock.json
        fi
        npm install --package-lock-only --no-audit

    - name: Flush old build
      run: rm -rf dist/
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        #cache: 'npm'
        #cache-dependency-path: './extension/package-lock.json'
        
    - name: Install dependencies
      #run: npm ci --prefer-offline
      run: npm install --prefer-offline
        
      
    - name: Show environment info
      run: |
        echo "Node version:"
        node --version
        echo "NPM version:"
        npm --version
        echo "Directory structure:"
        ls -R
        echo "package.json contents:"
        cat package.json
        
    - name: Type check
      run: npm run type-check
        
    - name: Build extension
      run: |
        set -ex
        npm run build
        echo "Build output:"
        ls -la dist/

    # Debug output
    - name: Show build results
      if: always()
      run: |
        echo "Current directory:"
        pwd
        echo "Directory contents:"
        ls -lha
        echo "Dist directory contents (if exists):"
        ls -lha dist/ || echo "No dist directory"
        echo "Error logs (if any):"
        find . -name "*.log" -exec cat {} \;

    # Commit the built files
    - name: Commit bundled files
      uses: stefanzweifel/git-auto-commit-action@v5
      with:
        commit_message: "chore: Update extension bundles"
        file_pattern: "extension/dist/*"
        #branch: ${{ github.ref }}



---
File: .github/workflows/deduplicate-ghstore.yml
---
# .github/workflows/deduplicate.yml
# Workflow to automatically find and deduplicate objects in gh-store


name: Deduplicate GH-Store Objects

on:
  # schedule:
  #   - cron: '0 2 * * *' # Run daily at 2:00 UTC
  # push:
  #   branches: [ canonicalizer-newlabels ]
  #   paths: [ ".github/workflows/deduplicate.yml" ]
  # Allow manual triggering
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (no changes)'
        type: boolean
        default: true
      specific_object:
        description: 'Process specific object ID only (leave blank for all)'
        type: string
        required: false

jobs:
  deduplicate:
    runs-on: ubuntu-latest
    permissions:
      issues: write  # Needed to modify issues
      contents: read  # Needed to read code
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install gh-store
      
      - name: Run deduplication tool
        id: deduplicate
        run: |
          echo "Running deduplication process..."
          
          # Set up basic command
          CMD="python -m gh_store.tools.canonicalize --token ${{ secrets.GITHUB_TOKEN }} --repo ${{ github.repository }}"
          
          # Check if dry run
          if [[ "${{ github.event.inputs.dry_run }}" == "true" ]]; then
            CMD="$CMD --dry-run"
            echo "::notice::Running in dry-run mode - no changes will be made"
          fi
          
          # Check if specific object requested
          if [[ "${{ github.event.inputs.specific_object }}" != "" ]]; then
            OBJECT_ID="${{ github.event.inputs.specific_object }}"
            CMD="$CMD --object-id $OBJECT_ID"
            echo "::notice::Processing specific object: $OBJECT_ID"
          fi
          
          # First find duplicates and capture output
          echo "Finding duplicates..."
          FIND_OUTPUT=$(eval "$CMD --find-duplicates" 2>&1)
          echo "$FIND_OUTPUT"
          
          # Check if duplicates found
          if [[ "$FIND_OUTPUT" == *"No duplicate objects found"* ]]; then
            echo "::notice::No duplicate objects found!"
            echo "duplicates_found=false" >> $GITHUB_OUTPUT
            exit 0
          else
            echo "duplicates_found=true" >> $GITHUB_OUTPUT
          fi
          
          # Process duplicates
          echo "Processing duplicates..."
          DEDUP_OUTPUT=$(eval "$CMD --deduplicate" 2>&1)
          echo "$DEDUP_OUTPUT"
          
          # Extract metrics
          OBJECTS_PROCESSED=$(echo "$DEDUP_OUTPUT" | grep -o "Processed [0-9]* objects" | grep -o "[0-9]*")
          if [[ -z "$OBJECTS_PROCESSED" ]]; then
            OBJECTS_PROCESSED=0
          fi
          
          echo "objects_processed=$OBJECTS_PROCESSED" >> $GITHUB_OUTPUT
      
      - name: Create summary
        if: steps.deduplicate.outputs.duplicates_found == 'true'
        run: |
          echo "# Deduplication Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ github.event.inputs.dry_run }}" == "true" ]]; then
            echo "**DRY RUN** - No changes were made" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "Found duplicates for ${{ steps.deduplicate.outputs.objects_processed }} objects" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The deduplication process:" >> $GITHUB_STEP_SUMMARY
          echo "1. Identified objects with multiple issues" >> $GITHUB_STEP_SUMMARY
          echo "2. Selected the oldest issue as canonical for each object" >> $GITHUB_STEP_SUMMARY
          echo "3. Marked other issues as deprecated duplicates" >> $GITHUB_STEP_SUMMARY
          echo "4. Processed virtual merges to ensure data consistency" >> $GITHUB_STEP_SUMMARY
      
      - name: Handle no duplicates
        if: steps.deduplicate.outputs.duplicates_found == 'false'
        run: |
          echo "# Deduplication Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "âœ… No duplicate objects found in the repository." >> $GITHUB_STEP_SUMMARY



---
File: .github/workflows/ghstore-process-bulk.yml
---
# .github/workflows/ghstore-process-bulk.yml
name: Process Bulk Object Updates

on:
  workflow_dispatch:
    inputs:
      label:
        description: 'Label to process (default: stored-object)'
        required: true
        type: string
        default: 'stored-object'

jobs:
  process-updates:
    runs-on: ubuntu-latest
    permissions:
      issues: write 
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install gh-store rich loguru

      - name: Process Updates
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          LABEL: ${{ inputs.label }}
        run: |
          python - << 'EOF'
          import os
          from github import Github
          from gh_store.__main__ import CLI
          from loguru import logger
          from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn

          # Initialize GitHub client
          g = Github(os.environ["GITHUB_TOKEN"])
          repo = g.get_repo(os.environ["REPO"])
          label = os.environ["LABEL"]

          # Get all open issues with the specified label
          logger.info(f"Finding open issues with label: {label}")
          open_issues = list(repo.get_issues(state="open", labels=[label]))

          if not open_issues:
              logger.warning("No open issues found with specified label")
              exit(0)

          logger.info(f"Found {len(open_issues)} issues to process")

          # Initialize CLI
          cli = CLI()

          # Create progress bar
          with Progress(
              SpinnerColumn(),
              TextColumn("[bold blue]{task.description}"),
              BarColumn(),
              TextColumn("[progress.percentage]{task.percentage:>3.0f}%"),
          ) as progress:
              process_task = progress.add_task(
                  "Processing issues...",
                  total=len(open_issues)
              )

              for issue in open_issues:
                  logger.info(f"Processing issue #{issue.number}")
                  cli.process_updates(
                      issue=issue.number,
                      token=os.environ["GITHUB_TOKEN"],
                      repo=os.environ["REPO"]
                  )
                  progress.update(process_task, advance=1)

          logger.info("Bulk processing completed")
          EOF



---
File: .github/workflows/llamero-summarize.yaml
---
name: Llamero Summarization

on:
  # push:
  #   branches: [ main ]
  workflow_dispatch:

jobs:
  generate-summaries:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 1

    - name: Install llamero
      run: touch requirements.txt

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        #cache: 'pip'

    - name: Install llamero
      run: pip install llamero

    - name: Generate summaries
      run: |
        llamero summarize all
        #llamero tree --output summaries/tree.md



---
File: extension/background.ts
---
// background.ts
// Background script with simplified session tracking

import { GitHubStoreClient } from 'gh-store-client';
import { PaperManager } from './papers/manager';
import { SessionService } from './utils/session-service';
import { PopupManager } from './utils/popup-manager';
import { SourceIntegrationManager } from './source-integration/source-manager';
import { loguru } from './utils/logger';
import { PaperMetadata } from './papers/types';

// Import source plugins directly
import { arxivIntegration } from './source-integration/arxiv';
import { Message } from './source-integration/types';

const logger = loguru.getLogger('background');

// Global state
let githubToken = '';
let githubRepo = '';
let paperManager: PaperManager | null = null;
let sessionService: SessionService | null = null;
let popupManager: PopupManager | null = null;
let sourceManager: SourceIntegrationManager | null = null;

// Initialize sources
function initializeSources() {
  sourceManager = new SourceIntegrationManager();
  
  // Register built-in sources directly
  sourceManager.registerSource(arxivIntegration);
  
  logger.info('Source manager initialized');
  return sourceManager;
}

// Initialize everything
async function initialize() {
  try {
    // Initialize sources first
    initializeSources();
    
    // Load GitHub credentials
    const items = await chrome.storage.sync.get(['githubToken', 'githubRepo']);
    githubToken = items.githubToken || '';
    githubRepo = items.githubRepo || '';
    logger.info('Credentials loaded', { hasToken: !!githubToken, hasRepo: !!githubRepo });
    
    // Initialize paper manager if we have credentials
    if (githubToken && githubRepo) {
      const githubClient = new GitHubStoreClient(githubToken, githubRepo);
      
      // Pass the source manager to the paper manager
      paperManager = new PaperManager(githubClient, sourceManager!);
      logger.info('Paper manager initialized');
      
      // Initialize session service with paper manager
      sessionService = new SessionService(paperManager);
    } else {
      // Initialize session service without paper manager
      sessionService = new SessionService(null);
    }
    
    logger.info('Session service initialized');
    
    // Initialize popup manager
    popupManager = new PopupManager(
      () => sourceManager,
      () => paperManager
    );
    logger.info('Popup manager initialized');
    
    // Set up message listeners
    setupMessageListeners();
    
    // Initialize debug objects
    initializeDebugObjects();
  } catch (error) {
    logger.error('Initialization error', error);
  }
}

// Set up message listeners
function setupMessageListeners() {
  chrome.runtime.onMessage.addListener((message: any, sender, sendResponse) => {
    if (message.type === 'contentScriptReady' && sender.tab?.id) {
      logger.debug('Content script ready:', sender.tab.url);
      sendResponse({ success: true });
      return true;
    }
    
    if (message.type === 'paperMetadata' && message.metadata) {
      // Store metadata received from content script
      handlePaperMetadata(message.metadata);
      sendResponse({ success: true });
      return true;
    }
    
    if (message.type === 'getCurrentPaper') {
      const session = sessionService?.getCurrentSession();
      const paperMetadata = session 
        ? sessionService?.getPaperMetadata(session.sourceId, session.paperId)
        : null;
      
      logger.debug('Popup requested current paper', paperMetadata);
      sendResponse(paperMetadata);
      return true;
    }
    
    if (message.type === 'updateRating') {
      logger.debug('Rating update requested:', message.rating);
      handleUpdateRating(message.rating, sendResponse);
      return true; // Will respond asynchronously
    }
    
    if (message.type === 'startSession') {
      handleStartSession(message.sourceId, message.paperId);
      sendResponse({ success: true });
      return true;
    }
    
    if (message.type === 'sessionHeartbeat') {
      handleSessionHeartbeat();
      sendResponse({ success: true });
      return true;
    }
    
    if (message.type === 'endSession') {
      handleEndSession(message.reason || 'user_action');
      sendResponse({ success: true });
      return true;
    }

    // New handler for manual paper logging from popup
    if (message.type === 'manualPaperLog' && message.metadata) {
      handleManualPaperLog(message.metadata)
        .then(() => sendResponse({ success: true }))
        .catch(error => {
          logger.error('Error handling manual paper log', error);
          sendResponse({ 
            success: false, 
            error: error instanceof Error ? error.message : 'Unknown error' 
          });
        });
      return true; // Will respond asynchronously
    }
    
    // Other message handlers are managed by PopupManager
    
    return false; // Not handled
  });
}

// Handle paper metadata from content script
async function handlePaperMetadata(metadata: PaperMetadata) {
  logger.info(`Received metadata for ${metadata.sourceId}:${metadata.paperId}`);
  
  try {
    // Store metadata in session service
    if (sessionService) {
      sessionService.storePaperMetadata(metadata);
    }
    
    // Store in GitHub if we have a paper manager
    if (paperManager) {
      await paperManager.getOrCreatePaper(metadata);
      logger.debug('Paper metadata stored in GitHub');
    }
  } catch (error) {
    logger.error('Error handling paper metadata', error);
  }
}

// Handle rating update
async function handleUpdateRating(rating: string, sendResponse: (response: any) => void) {
  if (!paperManager || !sessionService) {
    sendResponse({ success: false, error: 'Services not initialized' });
    return;
  }

  const session = sessionService.getCurrentSession();
  if (!session) {
    sendResponse({ success: false, error: 'No current session' });
    return;
  }

  const metadata = sessionService.getPaperMetadata();
  if (!metadata) {
    sendResponse({ success: false, error: 'No paper metadata available' });
    return;
  }

  try {
    await paperManager.updateRating(
      session.sourceId,
      session.paperId, 
      rating,
      metadata
    );
    
    // Update stored metadata with new rating
    metadata.rating = rating;
    
    sendResponse({ success: true });
  } catch (error) {
    logger.error('Error updating rating:', error);
    sendResponse({ success: false, error: error instanceof Error ? error.message : 'Unknown error' });
  }
}

// Handle session start request
function handleStartSession(sourceId: string, paperId: string) {
  if (!sessionService) {
    logger.error('Session service not initialized');
    return;
  }
  
  // Get metadata if available
  const existingMetadata = sessionService.getPaperMetadata(sourceId, paperId);
  
  // Start the session
  sessionService.startSession(sourceId, paperId, existingMetadata);
  logger.info(`Started session for ${sourceId}:${paperId}`);
}

// Handle session heartbeat
function handleSessionHeartbeat() {
  if (!sessionService) {
    logger.error('Session service not initialized');
    return;
  }
  
  sessionService.recordHeartbeat();
}

// Handle session end request
function handleEndSession(reason: string) {
  if (!sessionService) {
    logger.error('Session service not initialized');
    return;
  }
  
  const session = sessionService.getCurrentSession();
  if (session) {
    logger.info(`Ending session: ${reason}`);
    sessionService.endSession();
  }
}

async function handleManualPaperLog(metadata: PaperMetadata): Promise<void> {
  logger.info(`Received manual paper log: ${metadata.sourceId}:${metadata.paperId}`);
  
  try {
    // Store metadata in session service
    if (sessionService) {
      sessionService.storePaperMetadata(metadata);
    }
    
    // Store in GitHub if we have a paper manager
    if (paperManager) {
      await paperManager.getOrCreatePaper(metadata);
      logger.debug('Manually logged paper stored in GitHub');
    }
  } catch (error) {
    logger.error('Error handling manual paper log', error);
    throw error;
  }
}

// Listen for credential changes
chrome.storage.onChanged.addListener(async (changes) => {
  logger.debug('Storage changes detected', Object.keys(changes));
  
  if (changes.githubToken) {
    githubToken = changes.githubToken.newValue;
  }
  if (changes.githubRepo) {
    githubRepo = changes.githubRepo.newValue;
  }
  
  // Reinitialize paper manager if credentials changed
  if (changes.githubToken || changes.githubRepo) {
    if (githubToken && githubRepo) {
      const githubClient = new GitHubStoreClient(githubToken, githubRepo);
      
      // Pass the source manager to the paper manager
      paperManager = new PaperManager(githubClient, sourceManager!);
      logger.info('Paper manager reinitialized');
      
      // Reinitialize session service with new paper manager
      sessionService = new SessionService(paperManager);
      logger.info('Session service reinitialized');
    }
  }
});

// Initialize debug objects in service worker scope
function initializeDebugObjects() {
  // @ts-ignore
  self.__DEBUG__ = {
    get paperManager() { return paperManager; },
    get sessionService() { return sessionService; },
    get popupManager() { return popupManager; },
    get sourceManager() { return sourceManager; },
    getGithubClient: () => paperManager ? paperManager.getClient() : null,
    getCurrentPaper: () => {
      const session = sessionService?.getCurrentSession();
      return session ? sessionService?.getPaperMetadata(session.sourceId, session.paperId) : null;
    },
    getSessionStats: () => sessionService?.getSessionStats(),
    getSources: () => sourceManager?.getAllSources(),
    forceEndSession: () => sessionService?.endSession()
  };

  logger.info('Debug objects registered');
}

// Initialize extension
initialize();



---
File: extension/config/session.ts
---
// config/session.ts
// Session configuration management

import { RawSessionConfig, SessionConfig } from './types';
import { loguru } from '../utils/logger';

const logger = loguru.getLogger('session-config');

// Default configuration values
export const DEFAULT_CONFIG: RawSessionConfig = {
    idleThresholdMinutes: 5,
    minSessionDurationSeconds: 30,
    requireContinuousActivity: true,  // If true, resets timer on idle
    logPartialSessions: false,        // If true, logs sessions even if under minimum duration
    activityUpdateIntervalSeconds: 1  // How often to update active time
};

/**
 * Load session configuration from storage
 */
export async function loadSessionConfig(): Promise<RawSessionConfig> {
    try {
        const items = await chrome.storage.sync.get('sessionConfig');
        const config = { ...DEFAULT_CONFIG, ...items.sessionConfig };
        logger.debug('Loaded session config', config);
        return config;
    } catch (error) {
        logger.error('Error loading session config', error);
        return DEFAULT_CONFIG;
    }
}

/**
 * Save session configuration to storage
 */
export async function saveSessionConfig(config: RawSessionConfig): Promise<void> {
    try {
        // Ensure values are the correct type
        const sanitizedConfig: RawSessionConfig = {
            idleThresholdMinutes: Number(config.idleThresholdMinutes),
            minSessionDurationSeconds: Number(config.minSessionDurationSeconds),
            requireContinuousActivity: Boolean(config.requireContinuousActivity),
            logPartialSessions: Boolean(config.logPartialSessions),
            activityUpdateIntervalSeconds: Number(config.activityUpdateIntervalSeconds)
        };
        
        await chrome.storage.sync.set({ sessionConfig: sanitizedConfig });
        logger.debug('Saved session config', sanitizedConfig);
    } catch (error) {
        logger.error('Error saving session config', error);
        throw error;
    }
}

/**
 * Convert configuration to milliseconds for internal use
 */
export function getConfigurationInMs(config: RawSessionConfig): SessionConfig {
    return {
        idleThreshold: config.idleThresholdMinutes * 60 * 1000,
        minSessionDuration: config.minSessionDurationSeconds * 1000,
        activityUpdateInterval: config.activityUpdateIntervalSeconds * 1000,
        requireContinuousActivity: config.requireContinuousActivity,
        logPartialSessions: config.logPartialSessions
    };
}



---
File: extension/config/types.ts
---
// config/types.ts
// Type definitions for configuration

export interface RawSessionConfig {
  // Time in minutes before considering user idle
  idleThresholdMinutes: number;
  
  // Minimum session duration in seconds to log
  minSessionDurationSeconds: number;
  
  // Whether to reset timer on idle
  requireContinuousActivity: boolean;
  
  // Whether to log sessions shorter than minimum duration
  logPartialSessions: boolean;
  
  // How often to update active time in seconds
  activityUpdateIntervalSeconds: number;
}

export interface SessionConfig {
  // Time in milliseconds before considering user idle
  idleThreshold: number;
  
  // Minimum session duration in milliseconds to log
  minSessionDuration: number;
  
  // Whether to reset timer on idle
  requireContinuousActivity: boolean;
  
  // Whether to log sessions shorter than minimum duration
  logPartialSessions: boolean;
  
  // How often to update active time in milliseconds
  activityUpdateInterval: number;
}

export interface StorageConfig {
  // GitHub access token
  githubToken: string;
  
  // GitHub repository (owner/repo)
  githubRepo: string;
  
  // Session tracking configuration
  sessionConfig: RawSessionConfig;
}



---
File: extension/content.ts
---
// content.ts
// Content script with simplified session tracking

import { LinkProcessor } from './source-integration/link-processor';
import { SourceIntegration, Message } from './source-integration/types';
import { PaperMetadata } from './papers/types';
import { loguru } from './utils/logger';
import { BaseSourceIntegration } from './source-integration/base-source';
import { generatePaperIdFromUrl } from './utils/metadata-extractor';

// Import source plugins directly
import { arxivIntegration } from './source-integration/arxiv';
//import { pdfIntegration } from './source-integration/pdf';

const logger = loguru.getLogger('content-script');

logger.info('Paper Tracker content script loaded');

// Available source integrations
const sourceIntegrations: SourceIntegration[] = [
  arxivIntegration,
  //pdfIntegration,
  // Add more sources as they become available
];

// Base source for fallback processing
const baseSource = new BaseSourceIntegration();

// Track active popup
let activePopup: HTMLElement | null = null;

// Heartbeat interval
let heartbeatInterval: number | null = null;
const HEARTBEAT_INTERVAL = 5000; // 5 seconds

// Track tab visibility
let isTabVisible = true;

// Track current session
let currentSession: { sourceId: string; paperId: string } | null = null;

// Create link processor
const linkProcessor = new LinkProcessor((sourceId, paperId, link) => {
  // Callback when link is found
  injectAnnotationButton(link, sourceId, paperId);
});

// Initialize sources
function initializeSources() {
  // Register each source with the link processor
  for (const source of sourceIntegrations) {
    logger.debug(`Initializing source: ${source.id}`);
    
    // Register patterns with link processor
    source.urlPatterns.forEach(pattern => {
      linkProcessor.registerPattern({
        sourceId: source.id,
        pattern,
        extractPaperId: (url: string) => source.extractPaperId(url)
      });
    });
  }
}

// Inject common styles
function injectStyles() {
  if (document.getElementById('paper-tracker-styles')) {
    return; // Already injected
  }
  
  const styles = `
  .paper-annotator {
    display: inline-block;
    margin-left: 4px;
    cursor: pointer;
    font-size: 0.9em;
    opacity: 0.7;
    transition: opacity 0.2s;
    vertical-align: baseline;
  }

  .paper-annotator:hover {
    opacity: 1;
  }

  .paper-popup-wrapper {
    position: fixed;
    z-index: 10000;
  }

  .paper-popup {
    position: relative;
    background: white;
    border: 1px solid #ddd;
    border-radius: 6px;
    padding: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    width: 300px;
    box-sizing: border-box;
  }

  .paper-popup-header {
    font-weight: bold;
    margin-bottom: 8px;
    line-height: 1.4;
    font-size: 1em;
  }

  .paper-popup-meta {
    color: #666;
    font-size: 0.85em;
    margin-bottom: 12px;
    line-height: 1.4;
  }

  .paper-popup-buttons {
    display: flex;
    gap: 8px;
    margin: 8px 0;
  }

  .paper-popup button {
    padding: 6px 12px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: #f5f5f5;
    cursor: pointer;
    transition: all 0.2s ease;
    font-size: 0.9em;
  }

  .paper-popup button:hover {
    background: #e8e8e8;
    border-color: #ccc;
  }

  .paper-popup button.active {
    background: #e0e0e0;
    border-color: #aaa;
  }

  .paper-popup textarea {
    width: calc(100% - 16px);
    min-height: 80px;
    margin: 8px 0;
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    resize: vertical;
    font-family: inherit;
    font-size: 0.9em;
    line-height: 1.4;
    box-sizing: border-box;
  }

  .paper-popup textarea:focus {
    outline: none;
    border-color: #aaa;
  }

  .paper-popup-actions {
    display: flex;
    justify-content: flex-end;
    gap: 8px;
    margin-top: 12px;
  }

  .paper-popup .save-button {
    background: #2563eb;
    color: white;
    border-color: #2563eb;
  }

  .paper-popup .save-button:hover {
    background: #1d4ed8;
    border-color: #1d4ed8;
  }
  `;
  
  const styleSheet = document.createElement('style');
  styleSheet.id = 'paper-tracker-styles';
  styleSheet.textContent = styles;
  document.head.appendChild(styleSheet);
  
  logger.debug('Injected styles');
}

// Add annotation button to link
function injectAnnotationButton(link: HTMLAnchorElement, sourceId: string, paperId: string): void {
  // Skip if already processed
  if (link.nextSibling && 
      link.nextSibling.nodeType === Node.ELEMENT_NODE &&
      (link.nextSibling as Element).classList.contains('paper-annotator')) {
    return;
  }
  
  // Create annotator button
  const annotator = document.createElement('span');
  annotator.className = 'paper-annotator';
  annotator.textContent = 'ðŸ“';
  annotator.title = 'Add annotation';
  
  // Store data attributes
  annotator.dataset.sourceId = sourceId;
  annotator.dataset.paperId = paperId;
  
  // Add click handler
  annotator.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    
    // Send message to background script to show popup
    chrome.runtime.sendMessage({
      type: 'showAnnotationPopup',
      sourceId,
      paperId,
      position: {
        x: e.clientX,
        y: e.clientY
      }
    });
  });
  
  // Add to page next to link
  link.parentNode?.insertBefore(annotator, link.nextSibling);
}

// Get source that can handle a URL
function getSourceForUrl(url: string): SourceIntegration | null {
  for (const source of sourceIntegrations) {
    if (source.canHandleUrl(url)) {
      return source;
    }
  }
  return null;
}

// Set up click-outside handler for popups
document.addEventListener('click', (e) => {
  if (activePopup && 
      !activePopup.contains(e.target as Node) && 
      !(e.target as Element).classList.contains('paper-annotator')) {
    activePopup.parentElement?.remove();
    activePopup = null;
  }
});

// Start session tracking
function startSessionTracking(sourceId: string, paperId: string) {
  // Stop any existing heartbeat
  stopHeartbeat();
  
  // Only start tracking if tab is visible
  if (!isTabVisible) {
    logger.debug(`Not starting session for ${sourceId}:${paperId} because tab is not visible`);
    return;
  }
  
  // Update current session
  currentSession = { sourceId, paperId };
  
  // Tell background script to start a new session
  chrome.runtime.sendMessage({
    type: 'startSession',
    sourceId,
    paperId
  }, response => {
    if (response?.success) {
      logger.debug(`Started session for ${sourceId}:${paperId}`);
      
      // Start sending heartbeats
      startHeartbeat();
    } else {
      logger.error(`Failed to start session for ${sourceId}:${paperId}`, response?.error);
    }
  });
}

// Start sending heartbeats to background script
function startHeartbeat() {
  if (!currentSession) return;
  
  // Clear any existing interval
  stopHeartbeat();
  
  // Set new interval
  heartbeatInterval = window.setInterval(() => {
    if (!currentSession) return;
    
    chrome.runtime.sendMessage({
      type: 'sessionHeartbeat',
      sourceId: currentSession.sourceId,
      paperId: currentSession.paperId,
      timestamp: Date.now()
    });
  }, HEARTBEAT_INTERVAL);
  
  logger.debug(`Started heartbeat for ${currentSession.sourceId}:${currentSession.paperId}`);
}

// Stop sending heartbeats
function stopHeartbeat() {
  if (heartbeatInterval !== null) {
    clearInterval(heartbeatInterval);
    heartbeatInterval = null;
    logger.debug('Stopped heartbeat');
  }
}

// End the current session
function endCurrentSession(reason: string) {
  if (!currentSession) return;
  
  const { sourceId, paperId } = currentSession;
  
  // Stop heartbeat
  stopHeartbeat();
  
  // Send end session message
  chrome.runtime.sendMessage({
    type: 'endSession',
    sourceId,
    paperId,
    reason
  }, response => {
    logger.debug(`Ended session for ${sourceId}:${paperId}`, { reason });
  });
  
  // Clear current session
  currentSession = null;
}

// Process the current page
async function processCurrentPage(force: boolean = false): Promise<PaperMetadata | null> {
  const url = window.location.href;
  
  // Find a source that can handle this URL
  let source = getSourceForUrl(url);
  
  // If no source was found and force parameter is set, use base source
  if (!source && force) {
    logger.info(`No matching source found, but force parameter set. Using base source for: ${url}`);
    source = baseSource;
  }

  // If we still don't have a source, return null
  if (!source) {
    logger.debug(`No source found for URL: ${url}`);
    return null;
  }

  // Now that we have a source, extract the paperId
  const paperId = source.extractPaperId(url);
  if (!paperId) {
    logger.info(`Unable to determine a paperId for url: ${url}`);
    return null;
  }
  
  try {
    // Use source-specific extraction
    const metadata = await source.extractMetadata(document, paperId);
    
    if (metadata) {
      // Send metadata to background script
      chrome.runtime.sendMessage({
        type: 'paperMetadata',
        metadata
      });
      
      logger.debug(`Sent extracted metadata to background script for ${metadata.sourceId}:${metadata.paperId}`);
      
      // Start session tracking if tab is visible
      if (isTabVisible) {
        startSessionTracking(metadata.sourceId, metadata.paperId);
      }
      
      return metadata;
    }
  } catch (error) {
    logger.error(`Error extracting metadata for ${source.id}:${paperId}`, error);
  }
  
  return null;
}

// Visibility change listener
document.addEventListener('visibilitychange', () => {
  const wasVisible = isTabVisible;
  isTabVisible = document.visibilityState === 'visible';
  
  if (isTabVisible && !wasVisible) {
    // Tab has become visible again - restart session
    logger.info('Tab became visible again');
    
    // If we have a current session, restart it
    if (currentSession) {
      startSessionTracking(currentSession.sourceId, currentSession.paperId);
    } else {
      // Otherwise, try to process the page
      processCurrentPage();
    }
  } else if (!isTabVisible && wasVisible) {
    // Tab has become hidden - end current session
    logger.info('Tab hidden');
    if (currentSession) {
      endCurrentSession('tab_hidden');
    }
  }
});

// Focus/blur listeners
window.addEventListener('focus', () => {
  if (!isTabVisible) return; // Don't restart if tab is hidden
  
  logger.info('Window gained focus');
  
  // If we have a current session, restart it
  if (currentSession) {
    startSessionTracking(currentSession.sourceId, currentSession.paperId);
  } else {
    // Otherwise, try to process the page
    processCurrentPage();
  }
});

window.addEventListener('blur', () => {
  logger.info('Window lost focus');
  
  // End the current session
  if (currentSession) {
    endCurrentSession('window_blur');
  }
});

// Inform background when page is unloaded
window.addEventListener('beforeunload', () => {
  if (currentSession) {
    logger.info('Page unloading');
    endCurrentSession('page_unload');
  }
});

// Message handler for background script
chrome.runtime.onMessage.addListener((message: any, sender, sendResponse) => {
  logger.debug('Received message', message);

  if (message.type === 'extractPaperMetadata') {
    logger.debug('Received request to force paper metadata extraction');
    
    // Use processCurrentPage with force=true to enable fallback extraction
    processCurrentPage(true)
      .then(metadata => {
        if (metadata) {
          sendResponse({ success: true, metadata });
        } else {
          sendResponse({ success: false, error: 'Failed to extract metadata' });
        }
      })
      .catch(error => {
        logger.error('Error extracting metadata', error);
        sendResponse({ 
          success: false, 
          error: error instanceof Error ? error.message : 'Unknown error' 
        });
      });
    return true; // Will respond asynchronously
  }
  
  if (message.type === 'showPopup') {
    // Remove existing popup
    if (activePopup) {
      activePopup.parentElement?.remove();
      activePopup = null;
    }
    
    // Create popup wrapper
    const wrapper = document.createElement('div');
    wrapper.className = 'paper-popup-wrapper';
    
    // Position near click or element
    if (message.position) {
      wrapper.style.left = `${message.position.x}px`;
      wrapper.style.top = `${message.position.y}px`;
    }
    
    // Create popup
    const popup = document.createElement('div');
    popup.className = 'paper-popup';
    popup.innerHTML = message.html;
    
    // Add to page
    wrapper.appendChild(popup);
    document.body.appendChild(wrapper);
    
    // Set up event handlers
    if (message.handlers) {
      for (const handler of message.handlers) {
        const elements = popup.querySelectorAll(handler.selector);
        elements.forEach(element => {
          element.addEventListener(handler.event, () => {
            chrome.runtime.sendMessage({
              type: 'popupAction',
              action: handler.action,
              sourceId: message.sourceId,
              paperId: message.paperId,
              data: {
                value: element.tagName === 'TEXTAREA' ? 
                  (element as HTMLTextAreaElement).value : 
                  (element as HTMLElement).getAttribute('data-vote'),
                checked: element.tagName === 'INPUT' ? 
                  (element as HTMLInputElement).checked : undefined,
                id: (element as HTMLElement).id
              }
            });
          });
        });
      }
    }
    
    // Save reference
    activePopup = popup;
    
    sendResponse({ success: true });
    return true;
  }
  
  if (message.type === 'processPage') {
    // Re-process the entire page
    linkProcessor.processLinks(document);
    processCurrentPage();
    sendResponse({ success: true });
    return true;
  }
});

// Initialize
(async function initialize() {
  // Inject styles
  injectStyles();
  
  // Initialize sources
  initializeSources();
  
  // Process links
  linkProcessor.processLinks(document);
  
  // Start observing for new links
  linkProcessor.startObserving(document);
  
  // Set initial tab visibility
  isTabVisible = document.visibilityState === 'visible';
  
  // Process current page
  processCurrentPage();
  
  // Tell background script we're ready and what page we're on
  chrome.runtime.sendMessage(
    { 
      type: 'contentScriptReady', 
      url: window.location.href 
    },
    (response) => {
      if (response?.success) {
        logger.debug('Background script acknowledged ready status');
      }
    }
  );
})();

// Set up observer for URL changes (single page apps)
let lastUrl = location.href;
new MutationObserver(() => {
  const url = location.href;
  if (url !== lastUrl) {
    // End any current session
    if (currentSession) {
      endCurrentSession('url_change');
    }
    
    // Update URL and process new page
    lastUrl = url;
    processCurrentPage();
  }
}).observe(document, { subtree: true, childList: true });



---
File: extension/dist/background.bundle.js
---
var f=(i=>(i.GH_STORE="gh-store",i.STORED_OBJECT="stored-object",i.DEPRECATED="deprecated-object",i.UID_PREFIX="UID:",i.ALIAS_TO_PREFIX="ALIAS-TO:",i))(f||{});var m=class{constructor(e={}){this.cache=new Map,this.maxSize=e.maxSize??1e3,this.ttl=e.ttl??1e3*60*60,this.accessOrder=[];}get(e){let t=this.cache.get(e);if(t){if(Date.now()-t.lastAccessed>this.ttl){this.cache.delete(e),this.removeFromAccessOrder(e);return}return t.lastAccessed=Date.now(),this.updateAccessOrder(e),t.issueNumber}}set(e,t,r){if(this.cache.size>=this.maxSize&&!this.cache.has(e)){let s=this.accessOrder[this.accessOrder.length-1];s&&(this.cache.delete(s),this.removeFromAccessOrder(s));}this.cache.set(e,{issueNumber:t,lastAccessed:Date.now(),createdAt:r.createdAt,updatedAt:r.updatedAt}),this.updateAccessOrder(e);}remove(e){this.cache.delete(e),this.removeFromAccessOrder(e);}clear(){this.cache.clear(),this.accessOrder=[];}getStats(){return {size:this.cache.size,maxSize:this.maxSize,ttl:this.ttl}}shouldRefresh(e,t){let r=this.cache.get(e);return r?t>r.updatedAt:!0}updateAccessOrder(e){this.removeFromAccessOrder(e),this.accessOrder.unshift(e);}removeFromAccessOrder(e){let t=this.accessOrder.indexOf(e);t>-1&&this.accessOrder.splice(t,1);}};var y="0.11.1";var d=class{constructor(e,t,r={}){if(this.token=e,this.repo=t,!this.repo)throw new Error("Repository is required");this.config={baseLabel:r.baseLabel??"stored-object",uidPrefix:r.uidPrefix??"UID:",reactions:{processed:r.reactions?.processed??"+1",initialState:r.reactions?.initialState??"rocket"}},this.cache=new m(r.cache);}isPublic(){return this.token===null}async fetchFromGitHub(e,t={}){let r=new URL(`https://api.github.com/repos/${this.repo}${e}`);t.params&&(Object.entries(t.params).forEach(([a,n])=>{r.searchParams.append(a,n);}),delete t.params);let s={Accept:"application/vnd.github.v3+json"};if(t.headers){let a=t.headers;Object.keys(a).forEach(n=>{s[n]=a[n];});}this.token&&(s.Authorization=`token ${this.token}`);let i=await fetch(r.toString(),{...t,headers:s});if(!i.ok)throw new Error(`GitHub API error: ${i.status}`);return i.json()}createCommentPayload(e,t,r){let s={_data:e,_meta:{client_version:y,timestamp:new Date().toISOString(),update_mode:"append",issue_number:t}};return r&&(s.type=r),s}async getObject(e){let t=this.cache.get(e),r;if(t)try{r=await this.fetchFromGitHub(`/issues/${t}`),this._verifyIssueLabels(r,e)||(this.cache.remove(e),r=void 0);}catch{this.cache.remove(e);}if(!r){let c=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:["gh-store",this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(","),state:"closed"}});if(!c||c.length===0)throw new Error(`No object found with ID: ${e}`);r=c[0];}if(!r?.body)throw new Error(`Invalid issue data received for ID: ${e}`);let s=JSON.parse(r.body),i=new Date(r.created_at),a=new Date(r.updated_at);return this.cache.set(e,r.number,{createdAt:i,updatedAt:a}),{meta:{objectId:e,label:`${this.config.uidPrefix}${e}`,issueNumber:r.number,createdAt:i,updatedAt:a,version:await this._getVersion(r.number)},data:s}}async createObject(e,t,r=[]){if(!this.token)throw new Error("Authentication required for creating objects");let s=`${this.config.uidPrefix}${e}`,i=["gh-store",this.config.baseLabel,s,...r],a=await this.fetchFromGitHub("/issues",{method:"POST",body:JSON.stringify({title:`Stored Object: ${e}`,body:JSON.stringify(t,null,2),labels:i})});this.cache.set(e,a.number,{createdAt:new Date(a.created_at),updatedAt:new Date(a.updated_at)});let n=this.createCommentPayload(t,a.number,"initial_state"),c=await this.fetchFromGitHub(`/issues/${a.number}/comments`,{method:"POST",body:JSON.stringify({body:JSON.stringify(n,null,2)})});return await this.fetchFromGitHub(`/issues/comments/${c.id}/reactions`,{method:"POST",body:JSON.stringify({content:this.config.reactions.processed})}),await this.fetchFromGitHub(`/issues/comments/${c.id}/reactions`,{method:"POST",body:JSON.stringify({content:this.config.reactions.initialState})}),await this.fetchFromGitHub(`/issues/${a.number}`,{method:"PATCH",body:JSON.stringify({state:"closed"})}),{meta:{objectId:e,label:s,issueNumber:a.number,createdAt:new Date(a.created_at),updatedAt:new Date(a.updated_at),version:1},data:t}}_verifyIssueLabels(e,t){let r=new Set([this.config.baseLabel,`${this.config.uidPrefix}${t}`]);return e.labels.some(s=>r.has(s.name))}async updateObject(e,t){if(!this.token)throw new Error("Authentication required for updating objects");let r=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(","),state:"all"}});if(!r||r.length===0)throw new Error(`No object found with ID: ${e}`);let s=r[0],i=this.createCommentPayload(t,s.number);return await this.fetchFromGitHub(`/issues/${s.number}/comments`,{method:"POST",body:JSON.stringify({body:JSON.stringify(i,null,2)})}),await this.fetchFromGitHub(`/issues/${s.number}`,{method:"PATCH",body:JSON.stringify({state:"open"})}),this.getObject(e)}async listAll(){let e=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:this.config.baseLabel,state:"closed"}}),t={};for(let r of e)if(!r.labels.some(s=>s.name==="archived"))try{let s=this._getObjectIdFromLabels(r),i=JSON.parse(r.body),a={objectId:s,label:s,issueNumber:r.number,createdAt:new Date(r.created_at),updatedAt:new Date(r.updated_at),version:await this._getVersion(r.number)};t[s]={meta:a,data:i};}catch{continue}return t}async listUpdatedSince(e){let t=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:this.config.baseLabel,state:"closed",since:e.toISOString()}}),r={};for(let s of t)if(!s.labels.some(i=>i.name==="archived"))try{let i=this._getObjectIdFromLabels(s),a=JSON.parse(s.body),n=new Date(s.updated_at);if(n>e){let c={objectId:i,label:i,issueNumber:s.number,createdAt:new Date(s.created_at),updatedAt:n,version:await this._getVersion(s.number)};r[i]={meta:c,data:a};}}catch{continue}return r}async getObjectHistory(e){let t=await this.fetchFromGitHub("/issues",{method:"GET",params:{labels:[this.config.baseLabel,`${this.config.uidPrefix}${e}`].join(","),state:"all"}});if(!t||t.length===0)throw new Error(`No object found with ID: ${e}`);let r=t[0],s=await this.fetchFromGitHub(`/issues/${r.number}/comments`),i=[];for(let a of s)try{let n=JSON.parse(a.body),c="update",u,p={client_version:"legacy",timestamp:a.created_at,update_mode:"append"};typeof n=="object"?"_data"in n?(c=n.type||"update",u=n._data,p=n._meta||p):"type"in n&&n.type==="initial_state"?(c="initial_state",u=n.data):u=n:u=n,i.push({timestamp:a.created_at,type:c,data:u,commentId:a.id});}catch{continue}return i}async _getVersion(e){return (await this.fetchFromGitHub(`/issues/${e}/comments`)).length+1}_getObjectIdFromLabels(e){for(let t of e.labels)if(t.name!==this.config.baseLabel&&t.name.startsWith(this.config.uidPrefix))return t.name.slice(this.config.uidPrefix.length);throw new Error(`No UID label found with prefix ${this.config.uidPrefix}`)}};var E={level:"info",silent:!1},A={error:3,warn:2,info:1,debug:0},b=class{constructor(e,t={}){this.entries=[];this.moduleName=e,this.config={...E,...t};}debug(e,t){this.log("debug",e,t);}info(e,t){this.log("info",e,t);}warn(e,t){this.log("warn",e,t);}error(e,t){this.log("error",e,t);}log(e,t,r){if(A[e]<A[this.config.level])return;let s={timestamp:new Date().toISOString(),level:e,module:this.moduleName,message:t,metadata:r};this.entries.push(s);}getEntries(){return [...this.entries]}clearEntries(){this.entries=[];}configure(e){this.config={...this.config,...e};}getConfig(){return {...this.config}}};new b("CanonicalStore");

// extension/papers/types.ts
// Updated for heartbeat-based session tracking
/**
 * Type guard for interaction log
 */
function isInteractionLog(data) {
    const log = data;
    return (typeof log === 'object' &&
        log !== null &&
        typeof log.sourceId === 'string' &&
        typeof log.paperId === 'string' &&
        Array.isArray(log.interactions));
}

// utils/logger.ts
// Logging utility wrapping loguru
/**
 * Logger class for consistent logging throughout the extension
 */
class Logger {
    constructor(module) {
        this.module = module;
    }
    /**
     * Log debug message
     */
    debug(message, data) {
        console.debug(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log info message
     */
    info(message, data) {
        console.info(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log warning message
     */
    warning(message, data) {
        console.warn(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log error message
     */
    error(message, data) {
        console.error(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
}
/**
 * Loguru mock for browser extension use
 */
class LoguruMock {
    /**
     * Get logger for a module
     */
    getLogger(module) {
        return new Logger(module);
    }
}
// Export singleton instance
const loguru = new LoguruMock();

const logger$7 = loguru.getLogger('paper-manager');
class PaperManager {
    constructor(client, sourceManager) {
        this.client = client;
        this.sourceManager = sourceManager;
        logger$7.debug('Paper manager initialized');
    }
    /**
     * Get paper by source and ID
     */
    async getPaper(sourceId, paperId) {
        const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
        try {
            const obj = await this.client.getObject(objectId);
            return obj.data;
        }
        catch (error) {
            if (error instanceof Error && error.message.includes('No object found')) {
                return null;
            }
            throw error;
        }
    }
    /**
     * Get or create paper metadata
     */
    async getOrCreatePaper(paperData) {
        const { sourceId, paperId } = paperData;
        const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
        const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
        try {
            const obj = await this.client.getObject(objectId);
            const data = obj.data;
            logger$7.debug(`Retrieved existing paper: ${paperIdentifier}`);
            return data;
        }
        catch (error) {
            if (error instanceof Error && error.message.includes('No object found')) {
                // Create new paper
                const defaultPaperData = {
                    ...paperData,
                    timestamp: new Date().toISOString(),
                    rating: paperData.rating || 'novote'
                };
                const newobj = await this.client.createObject(objectId, defaultPaperData, ["TODO:hydrate-metadata"]);
                logger$7.debug(`Created new paper: ${paperIdentifier}`);
                // reopen to trigger metadata hydration
                await this.client.fetchFromGitHub(`/issues/${newobj.meta.issueNumber}`, {
                    method: "PATCH",
                    body: JSON.stringify({ state: "open" })
                });
                return defaultPaperData;
            }
            throw error;
        }
    }
    /**
     * Get or create interaction log for a paper
     */
    async getOrCreateInteractionLog(sourceId, paperId) {
        const objectId = this.sourceManager.formatObjectId('interactions', sourceId, paperId);
        const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
        try {
            const obj = await this.client.getObject(objectId);
            const data = obj.data;
            if (isInteractionLog(data)) {
                return data;
            }
            throw new Error('Invalid interaction log format');
        }
        catch (error) {
            if (error instanceof Error && error.message.includes('No object found')) {
                const newLog = {
                    sourceId,
                    paperId,
                    interactions: []
                };
                await this.client.createObject(objectId, newLog);
                logger$7.debug(`Created new interaction log: ${paperIdentifier}`);
                return newLog;
            }
            throw error;
        }
    }
    /**
     * Get GitHub client instance
     */
    getClient() {
        return this.client;
    }
    /**
     * Log a reading session
     */
    async logReadingSession(sourceId, paperId, session, paperData) {
        // Ensure paper exists
        if (paperData) {
            await this.getOrCreatePaper({
                sourceId,
                paperId,
                url: paperData.url || this.sourceManager.formatPaperId(sourceId, paperId),
                title: paperData.title || paperId,
                authors: paperData.authors || '',
                abstract: paperData.abstract || '',
                timestamp: new Date().toISOString(),
                rating: 'novote',
                publishedDate: paperData.publishedDate || '',
                tags: paperData.tags || []
            });
        }
        // Log the session as an interaction
        await this.addInteraction(sourceId, paperId, {
            type: 'reading_session',
            timestamp: new Date().toISOString(),
            data: session
        });
        const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
        logger$7.info(`Logged reading session for ${paperIdentifier}`, { duration: session.duration_seconds });
    }
    /**
     * Log an annotation
     */
    async logAnnotation(sourceId, paperId, key, value, paperData) {
        // Ensure paper exists
        if (paperData) {
            await this.getOrCreatePaper({
                sourceId,
                paperId,
                url: paperData.url || this.sourceManager.formatPaperId(sourceId, paperId),
                title: paperData.title || paperId,
                authors: paperData.authors || '',
                abstract: paperData.abstract || '',
                timestamp: new Date().toISOString(),
                rating: 'novote',
                publishedDate: paperData.publishedDate || '',
                tags: paperData.tags || []
            });
        }
        // Log the annotation as an interaction
        await this.addInteraction(sourceId, paperId, {
            type: 'annotation',
            timestamp: new Date().toISOString(),
            data: { key, value }
        });
        const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
        logger$7.info(`Logged annotation for ${paperIdentifier}`, { key });
    }
    /**
     * Update paper rating
     */
    async updateRating(sourceId, paperId, rating, paperData) {
        // Ensure paper exists and get current data
        const paper = await this.getOrCreatePaper({
            sourceId,
            paperId,
            url: paperData?.url || this.sourceManager.formatPaperId(sourceId, paperId),
            title: paperData?.title || paperId,
            authors: paperData?.authors || '',
            abstract: paperData?.abstract || '',
            timestamp: new Date().toISOString(),
            rating: 'novote',
            publishedDate: paperData?.publishedDate || '',
            tags: paperData?.tags || []
        });
        const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
        // Update paper metadata with new rating
        await this.client.updateObject(objectId, {
            ...paper,
            rating
        });
        // Log rating change as an interaction
        await this.addInteraction(sourceId, paperId, {
            type: 'rating',
            timestamp: new Date().toISOString(),
            data: { rating }
        });
        const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
        logger$7.info(`Updated rating for ${paperIdentifier} to ${rating}`);
    }
    /**
     * Add interaction to log
     */
    async addInteraction(sourceId, paperId, interaction) {
        const log = await this.getOrCreateInteractionLog(sourceId, paperId);
        log.interactions.push(interaction);
        const objectId = this.sourceManager.formatObjectId('interactions', sourceId, paperId);
        await this.client.updateObject(objectId, log);
    }
}

// session-service.ts
const logger$6 = loguru.getLogger('session-service');
/**
 * Session tracking service for paper reading sessions
 *
 * Manages session state, heartbeats, and persistence
 * Designed for use in the background script (Service Worker)
 */
class SessionService {
    /**
     * Create a new session service
     */
    constructor(paperManager) {
        this.paperManager = paperManager;
        this.activeSession = null;
        this.timeoutId = null;
        this.paperMetadata = new Map();
        // Configuration
        this.HEARTBEAT_TIMEOUT = 15000; // 15 seconds
        logger$6.debug('Session service initialized');
    }
    /**
     * Start a new session for a paper
     */
    startSession(sourceId, paperId, metadata) {
        // End any existing session
        this.endSession();
        // Create new session
        this.activeSession = {
            sourceId,
            paperId,
            startTime: new Date(),
            heartbeatCount: 0,
            lastHeartbeatTime: new Date()
        };
        // Store metadata if provided
        if (metadata) {
            const key = `${sourceId}:${paperId}`;
            this.paperMetadata.set(key, metadata);
            logger$6.debug(`Stored metadata for ${key}`);
        }
        // Start timeout check
        this.scheduleTimeoutCheck();
        logger$6.info(`Started session for ${sourceId}:${paperId}`);
    }
    /**
     * Record a heartbeat for the current session
     */
    recordHeartbeat() {
        if (!this.activeSession) {
            return false;
        }
        this.activeSession.heartbeatCount++;
        this.activeSession.lastHeartbeatTime = new Date();
        // Reschedule timeout
        this.scheduleTimeoutCheck();
        if (this.activeSession.heartbeatCount % 12 === 0) { // Log every minute (12 x 5sec heartbeats)
            logger$6.debug(`Session received ${this.activeSession.heartbeatCount} heartbeats`);
        }
        return true;
    }
    /**
     * Schedule a check for heartbeat timeout
     */
    scheduleTimeoutCheck() {
        // Clear existing timeout
        if (this.timeoutId !== null) {
            clearTimeout(this.timeoutId);
        }
        // Set new timeout
        this.timeoutId = self.setTimeout(() => {
            this.checkTimeout();
        }, this.HEARTBEAT_TIMEOUT);
    }
    /**
     * Check if the session has timed out due to missing heartbeats
     */
    checkTimeout() {
        if (!this.activeSession)
            return;
        const now = Date.now();
        const lastTime = this.activeSession.lastHeartbeatTime.getTime();
        if ((now - lastTime) > this.HEARTBEAT_TIMEOUT) {
            logger$6.info('Session timeout detected');
            this.endSession();
        }
        else {
            this.scheduleTimeoutCheck();
        }
    }
    /**
     * End the current session and get the data
     */
    endSession() {
        if (!this.activeSession)
            return null;
        // Clear timeout
        if (this.timeoutId !== null) {
            clearTimeout(this.timeoutId);
            this.timeoutId = null;
        }
        const { sourceId, paperId, startTime, heartbeatCount } = this.activeSession;
        const endTime = new Date();
        // Calculate duration (5 seconds per heartbeat)
        const duration = heartbeatCount * 5;
        // Calculate total elapsed time
        const totalElapsed = endTime.getTime() - startTime.getTime();
        const totalElapsedSeconds = Math.round(totalElapsed / 1000);
        // Set idle seconds to the difference (for backward compatibility)
        const idleSeconds = Math.max(0, totalElapsedSeconds - duration);
        // Create session data
        const sessionData = {
            session_id: `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
            source_id: sourceId,
            paper_id: paperId,
            start_time: startTime.toISOString(),
            end_time: endTime.toISOString(),
            heartbeat_count: heartbeatCount,
            duration_seconds: duration,
            // Legacy fields
            idle_seconds: idleSeconds,
            total_elapsed_seconds: totalElapsedSeconds
        };
        // Store session if it was meaningful and we have a paper manager
        if (this.paperManager && heartbeatCount > 0) {
            const metadata = this.getPaperMetadata(sourceId, paperId);
            this.paperManager.logReadingSession(sourceId, paperId, sessionData, metadata)
                .catch(err => logger$6.error('Failed to store session', err));
        }
        logger$6.info(`Ended session for ${sourceId}:${paperId}`, {
            duration,
            heartbeats: heartbeatCount
        });
        // Clear active session
        this.activeSession = null;
        return sessionData;
    }
    /**
     * Check if a session is currently active
     */
    hasActiveSession() {
        return this.activeSession !== null;
    }
    /**
     * Get information about the current session
     */
    getCurrentSession() {
        if (!this.activeSession)
            return null;
        return {
            sourceId: this.activeSession.sourceId,
            paperId: this.activeSession.paperId
        };
    }
    /**
     * Get paper metadata for the current or specified session
     */
    getPaperMetadata(sourceId, paperId) {
        if (!sourceId || !paperId) {
            if (!this.activeSession)
                return undefined;
            sourceId = this.activeSession.sourceId;
            paperId = this.activeSession.paperId;
        }
        return this.paperMetadata.get(`${sourceId}:${paperId}`);
    }
    /**
     * Store paper metadata
     */
    storePaperMetadata(metadata) {
        const key = `${metadata.sourceId}:${metadata.paperId}`;
        this.paperMetadata.set(key, metadata);
    }
    /**
     * Get time since last heartbeat in milliseconds
     */
    getTimeSinceLastHeartbeat() {
        if (!this.activeSession) {
            return null;
        }
        return Date.now() - this.activeSession.lastHeartbeatTime.getTime();
    }
    /**
     * Get session statistics for debugging
     */
    getSessionStats() {
        if (!this.activeSession) {
            return { active: false };
        }
        return {
            active: true,
            sourceId: this.activeSession.sourceId,
            paperId: this.activeSession.paperId,
            startTime: this.activeSession.startTime.toISOString(),
            heartbeatCount: this.activeSession.heartbeatCount,
            lastHeartbeatTime: this.activeSession.lastHeartbeatTime.toISOString(),
            elapsedTime: Math.round((Date.now() - this.activeSession.startTime.getTime()) / 1000)
        };
    }
}

// extension/utils/popup-manager.ts
const logger$5 = loguru.getLogger('popup-manager');
/**
 * Manages all popup-related functionality
 */
class PopupManager {
    /**
     * Create a new popup manager
     */
    constructor(sourceManagerProvider, paperManagerProvider) {
        this.sourceManagerProvider = sourceManagerProvider;
        this.paperManagerProvider = paperManagerProvider;
        this.setupMessageListeners();
        logger$5.debug('Popup manager initialized');
    }
    /**
     * Set up message listeners for popup-related messages
     */
    setupMessageListeners() {
        chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
            // Handle popup actions (ratings, notes, etc.)
            if (message.type === 'popupAction') {
                this.handlePopupAction(message.sourceId, message.paperId, message.action, message.data).then(() => {
                    sendResponse({ success: true });
                }).catch(error => {
                    logger$5.error('Error handling popup action', error);
                    sendResponse({
                        success: false,
                        error: error instanceof Error ? error.message : 'Unknown error'
                    });
                });
                return true; // Will respond asynchronously
            }
            // Handle request to show annotation popup
            if (message.type === 'showAnnotationPopup' && sender.tab?.id) {
                this.handleShowAnnotationPopup(sender.tab.id, message.sourceId, message.paperId, message.position).then(() => {
                    sendResponse({ success: true });
                }).catch(error => {
                    logger$5.error('Error showing popup', error);
                    sendResponse({
                        success: false,
                        error: error instanceof Error ? error.message : 'Unknown error'
                    });
                });
                return true; // Will respond asynchronously
            }
            return false; // Not handled
        });
    }
    /**
     * Handle a request to show an annotation popup
     */
    async handleShowAnnotationPopup(tabId, sourceId, paperId, position) {
        logger$5.debug(`Showing annotation popup for ${sourceId}:${paperId}`);
        // Check if we have source and paper manager
        const sourceManager = this.sourceManagerProvider();
        const paperManager = this.paperManagerProvider();
        if (!sourceManager) {
            throw new Error('Source manager not initialized');
        }
        if (!paperManager) {
            throw new Error('Paper manager not initialized');
        }
        try {
            // Get paper data
            const paper = await paperManager.getPaper(sourceId, paperId);
            // Create popup HTML
            const html = this.createPopupHtml(paper || {
                sourceId,
                paperId,
                title: paperId,
                authors: '',
                abstract: '',
                url: '',
                timestamp: new Date().toISOString(),
                publishedDate: '',
                tags: [],
                rating: 'novote'
            });
            // Get handlers
            const handlers = this.getStandardPopupHandlers();
            // Send message to content script to show popup
            const message = {
                type: 'showPopup',
                sourceId,
                paperId,
                html,
                handlers,
                position
            };
            await chrome.tabs.sendMessage(tabId, message);
            logger$5.debug(`Sent popup to content script for ${sourceId}:${paperId}`);
        }
        catch (error) {
            logger$5.error(`Error showing popup for ${sourceId}:${paperId}`, error);
            throw error;
        }
    }
    /**
     * Handle popup actions (ratings, notes, etc.)
     */
    async handlePopupAction(sourceId, paperId, action, data) {
        const paperManager = this.paperManagerProvider();
        if (!paperManager) {
            throw new Error('Paper manager not initialized');
        }
        logger$5.debug(`Handling popup action: ${action}`, { sourceId, paperId });
        try {
            if (action === 'rate') {
                await paperManager.updateRating(sourceId, paperId, data.value);
                logger$5.info(`Updated rating for ${sourceId}:${paperId} to ${data.value}`);
            }
            else if (action === 'saveNotes') {
                if (data.value) {
                    await paperManager.logAnnotation(sourceId, paperId, 'notes', data.value);
                    logger$5.info(`Saved notes for ${sourceId}:${paperId}`);
                }
            }
        }
        catch (error) {
            logger$5.error(`Error handling action ${action} for ${sourceId}:${paperId}`, error);
            throw error;
        }
    }
    /**
     * Create HTML for paper popup
     */
    createPopupHtml(paper) {
        return `
      <div class="paper-popup-header">${paper.title || paper.paperId}</div>
      <div class="paper-popup-meta">${paper.authors || ''}</div>
      
      <div class="paper-popup-buttons">
        <button class="vote-button" data-vote="thumbsup" id="btn-thumbsup" ${paper.rating === 'thumbsup' ? 'class="active"' : ''}>ðŸ‘ Interesting</button>
        <button class="vote-button" data-vote="thumbsdown" id="btn-thumbsdown" ${paper.rating === 'thumbsdown' ? 'class="active"' : ''}>ðŸ‘Ž Not Relevant</button>
      </div>
      
      <textarea placeholder="Add notes about this paper..." id="paper-notes"></textarea>
      
      <div class="paper-popup-actions">
        <button class="save-button" id="btn-save">Save</button>
      </div>
    `;
    }
    /**
     * Get standard popup event handlers
     */
    getStandardPopupHandlers() {
        return [
            { selector: '#btn-thumbsup', event: 'click', action: 'rate' },
            { selector: '#btn-thumbsdown', event: 'click', action: 'rate' },
            { selector: '#btn-save', event: 'click', action: 'saveNotes' }
        ];
    }
}

// extension/source-integration/source-manager.ts
const logger$4 = loguru.getLogger('source-manager');
/**
 * Manages source integrations
 */
class SourceIntegrationManager {
    constructor() {
        this.sources = new Map();
        logger$4.info('Source integration manager initialized');
    }
    /**
     * Register a source integration
     */
    registerSource(source) {
        if (this.sources.has(source.id)) {
            logger$4.warning(`Source with ID '${source.id}' already registered, overwriting`);
        }
        this.sources.set(source.id, source);
        logger$4.info(`Registered source: ${source.name} (${source.id})`);
    }
    /**
     * Get all registered sources
     */
    getAllSources() {
        return Array.from(this.sources.values());
    }
    /**
     * Get source that can handle a URL
     */
    getSourceForUrl(url) {
        for (const source of this.sources.values()) {
            if (source.canHandleUrl(url)) {
                logger$4.debug(`Found source for URL '${url}': ${source.id}`);
                return source;
            }
        }
        logger$4.debug(`No source found for URL: ${url}`);
        return null;
    }
    /**
     * Get source by ID
     */
    getSourceById(sourceId) {
        const source = this.sources.get(sourceId);
        return source || null;
    }
    /**
     * Extract paper ID from URL using appropriate source
     */
    extractPaperId(url) {
        for (const source of this.sources.values()) {
            if (source.canHandleUrl(url)) {
                const paperId = source.extractPaperId(url);
                if (paperId) {
                    logger$4.debug(`Extracted paper ID '${paperId}' from URL using ${source.id}`);
                    return { sourceId: source.id, paperId };
                }
            }
        }
        logger$4.debug(`Could not extract paper ID from URL: ${url}`);
        return null;
    }
    /**
     * Format a paper identifier using the appropriate source
     */
    formatPaperId(sourceId, paperId) {
        const source = this.sources.get(sourceId);
        if (source) {
            return source.formatPaperId(paperId);
        }
        // Fallback if source not found
        logger$4.warning(`Source '${sourceId}' not found, using default format for paper ID`);
        return `${sourceId}.${paperId}`;
    }
    /**
     * Format an object ID using the appropriate source
     */
    formatObjectId(type, sourceId, paperId) {
        const source = this.sources.get(sourceId);
        if (source) {
            return source.formatObjectId(type, paperId);
        }
        // Fallback if source not found
        logger$4.warning(`Source '${sourceId}' not found, using default format for object ID`);
        return `${type}:${sourceId}.${paperId}`;
    }
    /**
     * Get all content script match patterns
     */
    getAllContentScriptMatches() {
        const patterns = [];
        for (const source of this.sources.values()) {
            patterns.push(...source.contentScriptMatches);
        }
        return patterns;
    }
}

// extension/utils/metadata-extractor.ts
const logger$3 = loguru.getLogger('metadata-extractor');
// Constants for standard source types
const SOURCE_TYPES = {
    PDF: 'pdf',
    URL: 'url',
};
/**
 * Base class for metadata extraction with customizable extraction methods
 * Each method can be overridden to provide source-specific extraction
 */
class MetadataExtractor {
    /**
     * Create a new metadata extractor for a document
     */
    constructor(document) {
        this.document = document;
        this.url = document.location.href;
        logger$3.debug('Initialized metadata extractor for:', this.url);
    }
    /**
     * Helper method to get content from meta tags
     */
    getMetaContent(selector) {
        const element = this.document.querySelector(selector);
        return element ? element.getAttribute('content') || '' : '';
    }
    /**
     * Extract and return all metadata fields
     */
    extract() {
        logger$3.debug('Extracting metadata from page:', this.url);
        const metadata = {
            title: this.extractTitle(),
            authors: this.extractAuthors(),
            description: this.extractDescription(),
            publishedDate: this.extractPublishedDate(),
            doi: this.extractDoi(),
            journalName: this.extractJournalName(),
            tags: this.extractTags(),
            url: this.url
        };
        logger$3.debug('Metadata extraction complete:', metadata);
        return metadata;
    }
    /**
     * Extract title from document
     * Considers multiple metadata standards with priority order
     */
    extractTitle() {
        // Title extraction - priority order
        return (
        // Dublin Core
        this.getMetaContent('meta[name="DC.Title"]') ||
            // Citation
            this.getMetaContent('meta[name="citation_title"]') ||
            // Open Graph
            this.getMetaContent('meta[property="og:title"]') ||
            // Standard meta
            this.getMetaContent('meta[name="title"]') ||
            // Fallback to document title
            this.document.title);
    }
    /**
     * Extract authors from document
     * Handles multiple author formats and sources
     */
    extractAuthors() {
        // Get all citation authors (some pages have multiple citation_author tags)
        const citationAuthors = [];
        this.document.querySelectorAll('meta[name="citation_author"]').forEach(el => {
            const content = el.getAttribute('content');
            if (content)
                citationAuthors.push(content);
        });
        // Get all DC creators
        const dcCreators = [];
        this.document.querySelectorAll('meta[name="DC.Creator.PersonalName"]').forEach(el => {
            const content = el.getAttribute('content');
            if (content)
                dcCreators.push(content);
        });
        // Individual author elements
        const dcCreator = this.getMetaContent('meta[name="DC.Creator.PersonalName"]');
        const citationAuthor = this.getMetaContent('meta[name="citation_author"]');
        const ogAuthor = this.getMetaContent('meta[property="og:article:author"]') ||
            this.getMetaContent('meta[name="author"]');
        // Set authors with priority
        if (dcCreators.length > 0) {
            return dcCreators.join(', ');
        }
        else if (citationAuthors.length > 0) {
            return citationAuthors.join(', ');
        }
        else if (dcCreator) {
            return dcCreator;
        }
        else if (citationAuthor) {
            return citationAuthor;
        }
        else if (ogAuthor) {
            return ogAuthor;
        }
        return '';
    }
    /**
     * Extract description/abstract from document
     */
    extractDescription() {
        return (this.getMetaContent('meta[name="DC.Description"]') ||
            this.getMetaContent('meta[name="citation_abstract"]') ||
            this.getMetaContent('meta[property="og:description"]') ||
            this.getMetaContent('meta[name="description"]'));
    }
    /**
     * Extract publication date from document
     */
    extractPublishedDate() {
        return (this.getMetaContent('meta[name="DC.Date.issued"]') ||
            this.getMetaContent('meta[name="citation_date"]') ||
            this.getMetaContent('meta[property="article:published_time"]'));
    }
    /**
     * Extract DOI (Digital Object Identifier) from document
     */
    extractDoi() {
        return (this.getMetaContent('meta[name="DC.Identifier.DOI"]') ||
            this.getMetaContent('meta[name="citation_doi"]'));
    }
    /**
     * Extract journal name from document
     */
    extractJournalName() {
        return (this.getMetaContent('meta[name="DC.Source"]') ||
            this.getMetaContent('meta[name="citation_journal_title"]'));
    }
    /**
     * Extract keywords/tags from document
     */
    extractTags() {
        const keywords = this.getMetaContent('meta[name="keywords"]') ||
            this.getMetaContent('meta[name="DC.Subject"]');
        if (keywords) {
            return keywords.split(',').map(tag => tag.trim());
        }
        return [];
    }
    /**
     * Determine if the current URL is a PDF
     */
    isPdf() {
        return isPdfUrl(this.url);
    }
    /**
     * Get the source type (PDF or URL)
     */
    getSourceType() {
        return this.isPdf() ? SOURCE_TYPES.PDF : SOURCE_TYPES.URL;
    }
    /**
     * Generate a paper ID for the current URL
     */
    generatePaperId() {
        return generatePaperIdFromUrl(this.url);
    }
}
/**
 * Create a common metadata extractor for a document
 * Factory function for creating the default extractor
 */
function createMetadataExtractor(document) {
    return new MetadataExtractor(document);
}
/**
 * Generate a paper ID from a URL
 * Creates a consistent hash-based identifier
 */
function generatePaperIdFromUrl(url) {
    // Use a basic hash function to create an ID from the URL
    let hash = 0;
    for (let i = 0; i < url.length; i++) {
        const char = url.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32bit integer
    }
    // Create a positive hexadecimal string
    const positiveHash = Math.abs(hash).toString(16).toUpperCase();
    // Use the first 8 characters as the ID
    return positiveHash.substring(0, 8);
}
/**
 * Determine if a URL is a PDF
 */
function isPdfUrl(url) {
    return url.toLowerCase().endsWith('.pdf');
}

// extension/source-integration/base-source.ts
const logger$2 = loguru.getLogger('base-source');
/**
 * Base class for source integrations
 * Provides default implementations for all methods
 * Specific sources can override as needed
 */
class BaseSourceIntegration {
    constructor() {
        // Default properties - set for generic web pages
        this.id = 'url';
        this.name = 'Web Page';
        this.urlPatterns = [
            /^https?:\/\/(?!.*\.pdf($|\?|#)).*$/i // Match HTTP/HTTPS URLs that aren't PDFs
        ];
        this.contentScriptMatches = [];
    }
    /**
     * Check if this integration can handle the given URL
     * Default implementation checks against urlPatterns
     */
    canHandleUrl(url) {
        return this.urlPatterns.some(pattern => pattern.test(url));
    }
    /**
     * Extract paper ID from URL
     * Default implementation creates a hash from the URL
     */
    extractPaperId(url) {
        return generatePaperIdFromUrl(url);
    }
    /**
     * Create a metadata extractor for the given document
     * Override this method to provide a custom extractor for your source
     */
    createMetadataExtractor(document) {
        return createMetadataExtractor(document);
    }
    /**
     * Extract metadata from a page
     * Default implementation uses common metadata extraction
     */
    async extractMetadata(document, paperId) {
        try {
            logger$2.debug(`Extracting metadata using base extractor for ID: ${paperId}`);
            // Create a metadata extractor for this document
            const extractor = this.createMetadataExtractor(document);
            // Extract metadata
            const extracted = extractor.extract();
            const url = document.location.href;
            // Determine source type (PDF or URL)
            const sourceType = extractor.getSourceType();
            // Create PaperMetadata object
            return {
                sourceId: this.id,
                //paperId: this.formatPaperId(paperId),
                paperId: paperId,
                url: url,
                title: extracted.title || document.title || paperId,
                authors: extracted.authors || '',
                abstract: extracted.description || '',
                timestamp: new Date().toISOString(),
                rating: 'novote',
                publishedDate: extracted.publishedDate || '',
                tags: extracted.tags || [],
                doi: extracted.doi,
                journalName: extracted.journalName,
                sourceType: sourceType // Store the source type for reference
            };
        }
        catch (error) {
            logger$2.error('Error extracting metadata with base extractor', error);
            return null;
        }
    }
    /**
     * Format a paper identifier for this source
     * Default implementation uses the format: sourceId.paperId
     */
    formatPaperId(paperId) {
        return `${this.id}.${paperId}`;
    }
    /**
     * Parse a paper identifier specific to this source
     * Default implementation handles source.paperId format and extracts paperId
     */
    parsePaperId(identifier) {
        const prefix = `${this.id}.`;
        if (identifier.startsWith(prefix)) {
            return identifier.substring(prefix.length);
        }
        // Try legacy format (sourceId:paperId)
        const legacyPrefix = `${this.id}:`;
        if (identifier.startsWith(legacyPrefix)) {
            logger$2.debug(`Parsed legacy format identifier: ${identifier}`);
            return identifier.substring(legacyPrefix.length);
        }
        return null;
    }
    /**
     * Format a storage object ID for this source
     * Default implementation uses the format: type:sourceId.paperId
     */
    formatObjectId(type, paperId) {
        return `${type}:${this.formatPaperId(paperId)}`;
    }
}

// extension/source-integration/arxiv/index.ts
const logger$1 = loguru.getLogger('arxiv-integration');
/**
 * ArXiv integration with custom metadata extraction
 */
class ArXivIntegration extends BaseSourceIntegration {
    constructor() {
        super(...arguments);
        this.id = 'arxiv';
        this.name = 'arXiv.org';
        // URL patterns for papers
        this.urlPatterns = [
            /arxiv\.org\/(abs|pdf|html)\/([0-9.]+)/,
            /arxiv\.org\/\w+\/([0-9.]+)/
        ];
        // Content script matches
        this.contentScriptMatches = [
            "*://*.arxiv.org/*"
        ];
    }
    /**
     * Extract paper ID from URL
     */
    extractPaperId(url) {
        for (const pattern of this.urlPatterns) {
            const match = url.match(pattern);
            if (match) {
                return match[2] || match[1]; // The capture group with the paper ID
            }
        }
        return null;
    }
    /**
     * Extract metadata from page or fetch from API
     * Override parent method to handle the API fallback
     */
    async extractMetadata(document, paperId) {
        logger$1.info(`Extracting metadata for arXiv ID: ${paperId}`);
        // Try to extract from page first using our custom extractor
        const pageMetadata = await super.extractMetadata(document, paperId);
        // if (pageMetadata && pageMetadata.title && pageMetadata.authors) {
        logger$1.debug('Extracted metadata from page');
        return pageMetadata;
        // }
    }
}
// Export a singleton instance that can be used by both background and content scripts
const arxivIntegration = new ArXivIntegration();

// background.ts
const logger = loguru.getLogger('background');
// Global state
let githubToken = '';
let githubRepo = '';
let paperManager = null;
let sessionService = null;
let popupManager = null;
let sourceManager = null;
// Initialize sources
function initializeSources() {
    sourceManager = new SourceIntegrationManager();
    // Register built-in sources directly
    sourceManager.registerSource(arxivIntegration);
    logger.info('Source manager initialized');
    return sourceManager;
}
// Initialize everything
async function initialize() {
    try {
        // Initialize sources first
        initializeSources();
        // Load GitHub credentials
        const items = await chrome.storage.sync.get(['githubToken', 'githubRepo']);
        githubToken = items.githubToken || '';
        githubRepo = items.githubRepo || '';
        logger.info('Credentials loaded', { hasToken: !!githubToken, hasRepo: !!githubRepo });
        // Initialize paper manager if we have credentials
        if (githubToken && githubRepo) {
            const githubClient = new d(githubToken, githubRepo);
            // Pass the source manager to the paper manager
            paperManager = new PaperManager(githubClient, sourceManager);
            logger.info('Paper manager initialized');
            // Initialize session service with paper manager
            sessionService = new SessionService(paperManager);
        }
        else {
            // Initialize session service without paper manager
            sessionService = new SessionService(null);
        }
        logger.info('Session service initialized');
        // Initialize popup manager
        popupManager = new PopupManager(() => sourceManager, () => paperManager);
        logger.info('Popup manager initialized');
        // Set up message listeners
        setupMessageListeners();
        // Initialize debug objects
        initializeDebugObjects();
    }
    catch (error) {
        logger.error('Initialization error', error);
    }
}
// Set up message listeners
function setupMessageListeners() {
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
        if (message.type === 'contentScriptReady' && sender.tab?.id) {
            logger.debug('Content script ready:', sender.tab.url);
            sendResponse({ success: true });
            return true;
        }
        if (message.type === 'paperMetadata' && message.metadata) {
            // Store metadata received from content script
            handlePaperMetadata(message.metadata);
            sendResponse({ success: true });
            return true;
        }
        if (message.type === 'getCurrentPaper') {
            const session = sessionService?.getCurrentSession();
            const paperMetadata = session
                ? sessionService?.getPaperMetadata(session.sourceId, session.paperId)
                : null;
            logger.debug('Popup requested current paper', paperMetadata);
            sendResponse(paperMetadata);
            return true;
        }
        if (message.type === 'updateRating') {
            logger.debug('Rating update requested:', message.rating);
            handleUpdateRating(message.rating, sendResponse);
            return true; // Will respond asynchronously
        }
        if (message.type === 'startSession') {
            handleStartSession(message.sourceId, message.paperId);
            sendResponse({ success: true });
            return true;
        }
        if (message.type === 'sessionHeartbeat') {
            handleSessionHeartbeat();
            sendResponse({ success: true });
            return true;
        }
        if (message.type === 'endSession') {
            handleEndSession(message.reason || 'user_action');
            sendResponse({ success: true });
            return true;
        }
        // New handler for manual paper logging from popup
        if (message.type === 'manualPaperLog' && message.metadata) {
            handleManualPaperLog(message.metadata)
                .then(() => sendResponse({ success: true }))
                .catch(error => {
                logger.error('Error handling manual paper log', error);
                sendResponse({
                    success: false,
                    error: error instanceof Error ? error.message : 'Unknown error'
                });
            });
            return true; // Will respond asynchronously
        }
        // Other message handlers are managed by PopupManager
        return false; // Not handled
    });
}
// Handle paper metadata from content script
async function handlePaperMetadata(metadata) {
    logger.info(`Received metadata for ${metadata.sourceId}:${metadata.paperId}`);
    try {
        // Store metadata in session service
        if (sessionService) {
            sessionService.storePaperMetadata(metadata);
        }
        // Store in GitHub if we have a paper manager
        if (paperManager) {
            await paperManager.getOrCreatePaper(metadata);
            logger.debug('Paper metadata stored in GitHub');
        }
    }
    catch (error) {
        logger.error('Error handling paper metadata', error);
    }
}
// Handle rating update
async function handleUpdateRating(rating, sendResponse) {
    if (!paperManager || !sessionService) {
        sendResponse({ success: false, error: 'Services not initialized' });
        return;
    }
    const session = sessionService.getCurrentSession();
    if (!session) {
        sendResponse({ success: false, error: 'No current session' });
        return;
    }
    const metadata = sessionService.getPaperMetadata();
    if (!metadata) {
        sendResponse({ success: false, error: 'No paper metadata available' });
        return;
    }
    try {
        await paperManager.updateRating(session.sourceId, session.paperId, rating, metadata);
        // Update stored metadata with new rating
        metadata.rating = rating;
        sendResponse({ success: true });
    }
    catch (error) {
        logger.error('Error updating rating:', error);
        sendResponse({ success: false, error: error instanceof Error ? error.message : 'Unknown error' });
    }
}
// Handle session start request
function handleStartSession(sourceId, paperId) {
    if (!sessionService) {
        logger.error('Session service not initialized');
        return;
    }
    // Get metadata if available
    const existingMetadata = sessionService.getPaperMetadata(sourceId, paperId);
    // Start the session
    sessionService.startSession(sourceId, paperId, existingMetadata);
    logger.info(`Started session for ${sourceId}:${paperId}`);
}
// Handle session heartbeat
function handleSessionHeartbeat() {
    if (!sessionService) {
        logger.error('Session service not initialized');
        return;
    }
    sessionService.recordHeartbeat();
}
// Handle session end request
function handleEndSession(reason) {
    if (!sessionService) {
        logger.error('Session service not initialized');
        return;
    }
    const session = sessionService.getCurrentSession();
    if (session) {
        logger.info(`Ending session: ${reason}`);
        sessionService.endSession();
    }
}
async function handleManualPaperLog(metadata) {
    logger.info(`Received manual paper log: ${metadata.sourceId}:${metadata.paperId}`);
    try {
        // Store metadata in session service
        if (sessionService) {
            sessionService.storePaperMetadata(metadata);
        }
        // Store in GitHub if we have a paper manager
        if (paperManager) {
            await paperManager.getOrCreatePaper(metadata);
            logger.debug('Manually logged paper stored in GitHub');
        }
    }
    catch (error) {
        logger.error('Error handling manual paper log', error);
        throw error;
    }
}
// Listen for credential changes
chrome.storage.onChanged.addListener(async (changes) => {
    logger.debug('Storage changes detected', Object.keys(changes));
    if (changes.githubToken) {
        githubToken = changes.githubToken.newValue;
    }
    if (changes.githubRepo) {
        githubRepo = changes.githubRepo.newValue;
    }
    // Reinitialize paper manager if credentials changed
    if (changes.githubToken || changes.githubRepo) {
        if (githubToken && githubRepo) {
            const githubClient = new d(githubToken, githubRepo);
            // Pass the source manager to the paper manager
            paperManager = new PaperManager(githubClient, sourceManager);
            logger.info('Paper manager reinitialized');
            // Reinitialize session service with new paper manager
            sessionService = new SessionService(paperManager);
            logger.info('Session service reinitialized');
        }
    }
});
// Initialize debug objects in service worker scope
function initializeDebugObjects() {
    // @ts-ignore
    self.__DEBUG__ = {
        get paperManager() { return paperManager; },
        get sessionService() { return sessionService; },
        get popupManager() { return popupManager; },
        get sourceManager() { return sourceManager; },
        getGithubClient: () => paperManager ? paperManager.getClient() : null,
        getCurrentPaper: () => {
            const session = sessionService?.getCurrentSession();
            return session ? sessionService?.getPaperMetadata(session.sourceId, session.paperId) : null;
        },
        getSessionStats: () => sessionService?.getSessionStats(),
        getSources: () => sourceManager?.getAllSources(),
        forceEndSession: () => sessionService?.endSession()
    };
    logger.info('Debug objects registered');
}
// Initialize extension
initialize();
//# sourceMappingURL=background.bundle.js.map



---
File: extension/dist/content-script.js
---
!function(){"use strict";class e{constructor(e){this.module=e}debug(e,t){console.debug(`[${this.module}] ${e}`,void 0!==t?t:"")}info(e,t){console.info(`[${this.module}] ${e}`,void 0!==t?t:"")}warning(e,t){console.warn(`[${this.module}] ${e}`,void 0!==t?t:"")}error(e,t){console.error(`[${this.module}] ${e}`,void 0!==t?t:"")}}const t=new class{getLogger(t){return new e(t)}},n=t.getLogger("link-processor");const r=t.getLogger("metadata-extractor"),a="pdf",o="url";class s{constructor(e){this.document=e,this.url=e.location.href,r.debug("Initialized metadata extractor for:",this.url)}getMetaContent(e){const t=this.document.querySelector(e);return t&&t.getAttribute("content")||""}extract(){r.debug("Extracting metadata from page:",this.url);const e={title:this.extractTitle(),authors:this.extractAuthors(),description:this.extractDescription(),publishedDate:this.extractPublishedDate(),doi:this.extractDoi(),journalName:this.extractJournalName(),tags:this.extractTags(),url:this.url};return r.debug("Metadata extraction complete:",e),e}extractTitle(){return this.getMetaContent('meta[name="DC.Title"]')||this.getMetaContent('meta[name="citation_title"]')||this.getMetaContent('meta[property="og:title"]')||this.getMetaContent('meta[name="title"]')||this.document.title}extractAuthors(){const e=[];this.document.querySelectorAll('meta[name="citation_author"]').forEach((t=>{const n=t.getAttribute("content");n&&e.push(n)}));const t=[];this.document.querySelectorAll('meta[name="DC.Creator.PersonalName"]').forEach((e=>{const n=e.getAttribute("content");n&&t.push(n)}));const n=this.getMetaContent('meta[name="DC.Creator.PersonalName"]'),r=this.getMetaContent('meta[name="citation_author"]'),a=this.getMetaContent('meta[property="og:article:author"]')||this.getMetaContent('meta[name="author"]');return t.length>0?t.join(", "):e.length>0?e.join(", "):n||(r||(a||""))}extractDescription(){return this.getMetaContent('meta[name="DC.Description"]')||this.getMetaContent('meta[name="citation_abstract"]')||this.getMetaContent('meta[property="og:description"]')||this.getMetaContent('meta[name="description"]')}extractPublishedDate(){return this.getMetaContent('meta[name="DC.Date.issued"]')||this.getMetaContent('meta[name="citation_date"]')||this.getMetaContent('meta[property="article:published_time"]')}extractDoi(){return this.getMetaContent('meta[name="DC.Identifier.DOI"]')||this.getMetaContent('meta[name="citation_doi"]')}extractJournalName(){return this.getMetaContent('meta[name="DC.Source"]')||this.getMetaContent('meta[name="citation_journal_title"]')}extractTags(){const e=this.getMetaContent('meta[name="keywords"]')||this.getMetaContent('meta[name="DC.Subject"]');return e?e.split(",").map((e=>e.trim())):[]}isPdf(){return this.url.toLowerCase().endsWith(".pdf")}getSourceType(){return this.isPdf()?a:o}generatePaperId(){return i(this.url)}}function i(e){let t=0;for(let n=0;n<e.length;n++){t=(t<<5)-t+e.charCodeAt(n),t|=0}return Math.abs(t).toString(16).toUpperCase().substring(0,8)}const c=t.getLogger("base-source");class d{constructor(){this.id="url",this.name="Web Page",this.urlPatterns=[/^https?:\/\/(?!.*\.pdf($|\?|#)).*$/i],this.contentScriptMatches=[]}canHandleUrl(e){return this.urlPatterns.some((t=>t.test(e)))}extractPaperId(e){return i(e)}createMetadataExtractor(e){return function(e){return new s(e)}(e)}async extractMetadata(e,t){try{c.debug(`Extracting metadata using base extractor for ID: ${t}`);const n=this.createMetadataExtractor(e),r=n.extract(),a=e.location.href,o=n.getSourceType();return{sourceId:this.id,paperId:t,url:a,title:r.title||e.title||t,authors:r.authors||"",abstract:r.description||"",timestamp:(new Date).toISOString(),rating:"novote",publishedDate:r.publishedDate||"",tags:r.tags||[],doi:r.doi,journalName:r.journalName,sourceType:o}}catch(e){return c.error("Error extracting metadata with base extractor",e),null}}formatPaperId(e){return`${this.id}.${e}`}parsePaperId(e){const t=`${this.id}.`;if(e.startsWith(t))return e.substring(t.length);const n=`${this.id}:`;return e.startsWith(n)?(c.debug(`Parsed legacy format identifier: ${e}`),e.substring(n.length)):null}formatObjectId(e,t){return`${e}:${this.formatPaperId(t)}`}}const u=t.getLogger("arxiv-integration");const p=new class extends d{constructor(){super(...arguments),this.id="arxiv",this.name="arXiv.org",this.urlPatterns=[/arxiv\.org\/(abs|pdf|html)\/([0-9.]+)/,/arxiv\.org\/\w+\/([0-9.]+)/],this.contentScriptMatches=["*://*.arxiv.org/*"]}extractPaperId(e){for(const t of this.urlPatterns){const n=e.match(t);if(n)return n[2]||n[1]}return null}async extractMetadata(e,t){u.info(`Extracting metadata for arXiv ID: ${t}`);const n=await super.extractMetadata(e,t);return u.debug("Extracted metadata from page"),n}},l=t.getLogger("content-script");l.info("Paper Tracker content script loaded");const h=[p],g=new d;let m=null,b=null;let f=!0,x=null;const v=new class{constructor(e){this.patterns=[],this.observer=null,this.processedLinks=new Set,this.onLinkFound=e,n.debug("Link processor initialized")}registerPattern(e){this.patterns.push(e),n.debug(`Registered pattern for ${e.sourceId}`)}processLinks(e){e.querySelectorAll("a[href]").forEach((e=>{const t=this.getLinkId(e);if(!this.processedLinks.has(t)){this.processedLinks.add(t);for(const t of this.patterns)if(t.pattern.test(e.href)){const n=t.extractPaperId(e.href);if(n){this.onLinkFound(t.sourceId,n,e);break}}}}))}startObserving(e){this.observer&&this.observer.disconnect(),this.observer=new MutationObserver((t=>{let n=!1;t.forEach((e=>{e.addedNodes.forEach((e=>{if(e.nodeType===Node.ELEMENT_NODE){"A"===e.tagName&&(n=!0);e.querySelectorAll("a[href]").length>0&&(n=!0)}}))})),n&&this.processLinks(e)})),this.observer.observe(e.body,{childList:!0,subtree:!0}),n.debug("Started observing for DOM changes")}getLinkId(e){const t=this.getElementPath(e);return`${e.href}|${t}`}getElementPath(e){const t=[];let n=e;for(;n&&n!==document.body;){let e=n.tagName.toLowerCase();if(n.id)e+=`#${n.id}`;else{const t=Array.from(n.parentElement?.children||[]),r=t.indexOf(n)+1;t.length>1&&(e+=`:nth-child(${r})`)}t.unshift(e),n=n.parentElement}return t.join(" > ")}stopObserving(){this.observer&&(this.observer.disconnect(),this.observer=null,n.debug("Stopped observing DOM changes"))}}(((e,t,n)=>{!function(e,t,n){if(e.nextSibling&&e.nextSibling.nodeType===Node.ELEMENT_NODE&&e.nextSibling.classList.contains("paper-annotator"))return;const r=document.createElement("span");r.className="paper-annotator",r.textContent="ðŸ“",r.title="Add annotation",r.dataset.sourceId=t,r.dataset.paperId=n,r.addEventListener("click",(e=>{e.preventDefault(),e.stopPropagation(),chrome.runtime.sendMessage({type:"showAnnotationPopup",sourceId:t,paperId:n,position:{x:e.clientX,y:e.clientY}})})),e.parentNode?.insertBefore(r,e.nextSibling)}(n,e,t)}));function I(e,t){y(),f?(x={sourceId:e,paperId:t},chrome.runtime.sendMessage({type:"startSession",sourceId:e,paperId:t},(n=>{n?.success?(l.debug(`Started session for ${e}:${t}`),function(){if(!x)return;y(),b=window.setInterval((()=>{x&&chrome.runtime.sendMessage({type:"sessionHeartbeat",sourceId:x.sourceId,paperId:x.paperId,timestamp:Date.now()})}),5e3),l.debug(`Started heartbeat for ${x.sourceId}:${x.paperId}`)}()):l.error(`Failed to start session for ${e}:${t}`,n?.error)}))):l.debug(`Not starting session for ${e}:${t} because tab is not visible`)}function y(){null!==b&&(clearInterval(b),b=null,l.debug("Stopped heartbeat"))}function M(e){if(!x)return;const{sourceId:t,paperId:n}=x;y(),chrome.runtime.sendMessage({type:"endSession",sourceId:t,paperId:n,reason:e},(r=>{l.debug(`Ended session for ${t}:${n}`,{reason:e})})),x=null}async function w(e=!1){const t=window.location.href;let n=function(e){for(const t of h)if(t.canHandleUrl(e))return t;return null}(t);if(!n&&e&&(l.info(`No matching source found, but force parameter set. Using base source for: ${t}`),n=g),!n)return l.debug(`No source found for URL: ${t}`),null;const r=n.extractPaperId(t);if(!r)return l.info(`Unable to determine a paperId for url: ${t}`),null;try{const e=await n.extractMetadata(document,r);if(e)return chrome.runtime.sendMessage({type:"paperMetadata",metadata:e}),l.debug(`Sent extracted metadata to background script for ${e.sourceId}:${e.paperId}`),f&&I(e.sourceId,e.paperId),e}catch(e){l.error(`Error extracting metadata for ${n.id}:${r}`,e)}return null}document.addEventListener("click",(e=>{!m||m.contains(e.target)||e.target.classList.contains("paper-annotator")||(m.parentElement?.remove(),m=null)})),document.addEventListener("visibilitychange",(()=>{const e=f;f="visible"===document.visibilityState,f&&!e?(l.info("Tab became visible again"),x?I(x.sourceId,x.paperId):w()):!f&&e&&(l.info("Tab hidden"),x&&M("tab_hidden"))})),window.addEventListener("focus",(()=>{f&&(l.info("Window gained focus"),x?I(x.sourceId,x.paperId):w())})),window.addEventListener("blur",(()=>{l.info("Window lost focus"),x&&M("window_blur")})),window.addEventListener("beforeunload",(()=>{x&&(l.info("Page unloading"),M("page_unload"))})),chrome.runtime.onMessage.addListener(((e,t,n)=>{if(l.debug("Received message",e),"extractPaperMetadata"===e.type)return l.debug("Received request to force paper metadata extraction"),w(!0).then((e=>{n(e?{success:!0,metadata:e}:{success:!1,error:"Failed to extract metadata"})})).catch((e=>{l.error("Error extracting metadata",e),n({success:!1,error:e instanceof Error?e.message:"Unknown error"})})),!0;if("showPopup"===e.type){m&&(m.parentElement?.remove(),m=null);const t=document.createElement("div");t.className="paper-popup-wrapper",e.position&&(t.style.left=`${e.position.x}px`,t.style.top=`${e.position.y}px`);const r=document.createElement("div");if(r.className="paper-popup",r.innerHTML=e.html,t.appendChild(r),document.body.appendChild(t),e.handlers)for(const t of e.handlers){r.querySelectorAll(t.selector).forEach((n=>{n.addEventListener(t.event,(()=>{chrome.runtime.sendMessage({type:"popupAction",action:t.action,sourceId:e.sourceId,paperId:e.paperId,data:{value:"TEXTAREA"===n.tagName?n.value:n.getAttribute("data-vote"),checked:"INPUT"===n.tagName?n.checked:void 0,id:n.id}})}))}))}return m=r,n({success:!0}),!0}return"processPage"===e.type?(v.processLinks(document),w(),n({success:!0}),!0):void 0})),async function(){!function(){if(document.getElementById("paper-tracker-styles"))return;const e=document.createElement("style");e.id="paper-tracker-styles",e.textContent="\n  .paper-annotator {\n    display: inline-block;\n    margin-left: 4px;\n    cursor: pointer;\n    font-size: 0.9em;\n    opacity: 0.7;\n    transition: opacity 0.2s;\n    vertical-align: baseline;\n  }\n\n  .paper-annotator:hover {\n    opacity: 1;\n  }\n\n  .paper-popup-wrapper {\n    position: fixed;\n    z-index: 10000;\n  }\n\n  .paper-popup {\n    position: relative;\n    background: white;\n    border: 1px solid #ddd;\n    border-radius: 6px;\n    padding: 12px;\n    box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n    width: 300px;\n    box-sizing: border-box;\n  }\n\n  .paper-popup-header {\n    font-weight: bold;\n    margin-bottom: 8px;\n    line-height: 1.4;\n    font-size: 1em;\n  }\n\n  .paper-popup-meta {\n    color: #666;\n    font-size: 0.85em;\n    margin-bottom: 12px;\n    line-height: 1.4;\n  }\n\n  .paper-popup-buttons {\n    display: flex;\n    gap: 8px;\n    margin: 8px 0;\n  }\n\n  .paper-popup button {\n    padding: 6px 12px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    background: #f5f5f5;\n    cursor: pointer;\n    transition: all 0.2s ease;\n    font-size: 0.9em;\n  }\n\n  .paper-popup button:hover {\n    background: #e8e8e8;\n    border-color: #ccc;\n  }\n\n  .paper-popup button.active {\n    background: #e0e0e0;\n    border-color: #aaa;\n  }\n\n  .paper-popup textarea {\n    width: calc(100% - 16px);\n    min-height: 80px;\n    margin: 8px 0;\n    padding: 8px;\n    border: 1px solid #ddd;\n    border-radius: 4px;\n    resize: vertical;\n    font-family: inherit;\n    font-size: 0.9em;\n    line-height: 1.4;\n    box-sizing: border-box;\n  }\n\n  .paper-popup textarea:focus {\n    outline: none;\n    border-color: #aaa;\n  }\n\n  .paper-popup-actions {\n    display: flex;\n    justify-content: flex-end;\n    gap: 8px;\n    margin-top: 12px;\n  }\n\n  .paper-popup .save-button {\n    background: #2563eb;\n    color: white;\n    border-color: #2563eb;\n  }\n\n  .paper-popup .save-button:hover {\n    background: #1d4ed8;\n    border-color: #1d4ed8;\n  }\n  ",document.head.appendChild(e),l.debug("Injected styles")}(),function(){for(const e of h)l.debug(`Initializing source: ${e.id}`),e.urlPatterns.forEach((t=>{v.registerPattern({sourceId:e.id,pattern:t,extractPaperId:t=>e.extractPaperId(t)})}))}(),v.processLinks(document),v.startObserving(document),f="visible"===document.visibilityState,w(),chrome.runtime.sendMessage({type:"contentScriptReady",url:window.location.href},(e=>{e?.success&&l.debug("Background script acknowledged ready status")}))}();let E=location.href;new MutationObserver((()=>{const e=location.href;e!==E&&(x&&M("url_change"),E=e,w())})).observe(document,{subtree:!0,childList:!0})}();
//# sourceMappingURL=content-script.js.map



---
File: extension/dist/options.bundle.js
---
// utils/logger.ts
// Logging utility wrapping loguru
/**
 * Logger class for consistent logging throughout the extension
 */
class Logger {
    constructor(module) {
        this.module = module;
    }
    /**
     * Log debug message
     */
    debug(message, data) {
        console.debug(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log info message
     */
    info(message, data) {
        console.info(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log warning message
     */
    warning(message, data) {
        console.warn(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
    /**
     * Log error message
     */
    error(message, data) {
        console.error(`[${this.module}] ${message}`, data !== undefined ? data : '');
    }
}
/**
 * Loguru mock for browser extension use
 */
class LoguruMock {
    /**
     * Get logger for a module
     */
    getLogger(module) {
        return new Logger(module);
    }
}
// Export singleton instance
const loguru = new LoguruMock();

// config/session.ts
const logger = loguru.getLogger('session-config');
// Default configuration values
const DEFAULT_CONFIG = {
    idleThresholdMinutes: 5,
    minSessionDurationSeconds: 30,
    requireContinuousActivity: true, // If true, resets timer on idle
    logPartialSessions: false, // If true, logs sessions even if under minimum duration
    activityUpdateIntervalSeconds: 1 // How often to update active time
};
/**
 * Load session configuration from storage
 */
async function loadSessionConfig() {
    try {
        const items = await chrome.storage.sync.get('sessionConfig');
        const config = { ...DEFAULT_CONFIG, ...items.sessionConfig };
        logger.debug('Loaded session config', config);
        return config;
    }
    catch (error) {
        logger.error('Error loading session config', error);
        return DEFAULT_CONFIG;
    }
}
/**
 * Save session configuration to storage
 */
async function saveSessionConfig(config) {
    try {
        // Ensure values are the correct type
        const sanitizedConfig = {
            idleThresholdMinutes: Number(config.idleThresholdMinutes),
            minSessionDurationSeconds: Number(config.minSessionDurationSeconds),
            requireContinuousActivity: Boolean(config.requireContinuousActivity),
            logPartialSessions: Boolean(config.logPartialSessions),
            activityUpdateIntervalSeconds: Number(config.activityUpdateIntervalSeconds)
        };
        await chrome.storage.sync.set({ sessionConfig: sanitizedConfig });
        logger.debug('Saved session config', sanitizedConfig);
    }
    catch (error) {
        logger.error('Error saving session config', error);
        throw error;
    }
}

// options.ts
// Helper to set form values
function setFormValues(settings) {
    // GitHub settings
    if (settings.githubRepo) {
        document.getElementById('repo').value = settings.githubRepo;
    }
    if (settings.githubToken) {
        // Don't show the actual token, just indicate it's set
        document.getElementById('token').placeholder = 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢';
    }
    // Session settings
    document.getElementById('idleThreshold').value =
        String(settings.sessionConfig?.idleThresholdMinutes ?? DEFAULT_CONFIG.idleThresholdMinutes);
    document.getElementById('minDuration').value =
        String(settings.sessionConfig?.minSessionDurationSeconds ?? DEFAULT_CONFIG.minSessionDurationSeconds);
    document.getElementById('requireContinuous').checked =
        settings.sessionConfig?.requireContinuousActivity ?? DEFAULT_CONFIG.requireContinuousActivity;
    document.getElementById('logPartial').checked =
        settings.sessionConfig?.logPartialSessions ?? DEFAULT_CONFIG.logPartialSessions;
}
// Helper to get form values
function getFormValues() {
    return {
        githubRepo: document.getElementById('repo').value.trim(),
        githubToken: document.getElementById('token').value.trim(),
        sessionConfig: {
            idleThresholdMinutes: Number(document.getElementById('idleThreshold').value),
            minSessionDurationSeconds: Number(document.getElementById('minDuration').value),
            requireContinuousActivity: document.getElementById('requireContinuous').checked,
            logPartialSessions: document.getElementById('logPartial').checked,
            activityUpdateIntervalSeconds: DEFAULT_CONFIG.activityUpdateIntervalSeconds // Keep default
        }
    };
}
// Display status message
function showStatus(message, isError = false) {
    const status = document.getElementById('status');
    if (!status)
        return;
    status.textContent = message;
    status.className = `status ${isError ? 'error' : 'success'}`;
    // Clear status after 3 seconds if it's a success message
    if (!isError) {
        setTimeout(() => {
            if (status) {
                status.textContent = '';
                status.className = 'status';
            }
        }, 3000);
    }
}
// Validate settings before saving
async function validateSettings(settings) {
    // Validate repository format
    if (!/^[\w-]+\/[\w-]+$/.test(settings.githubRepo)) {
        throw new Error('Invalid repository format. Use username/repository');
    }
    // Validate the token by making a test API call
    const response = await fetch(`https://api.github.com/repos/${settings.githubRepo}`, {
        headers: {
            'Authorization': `token ${settings.githubToken}`,
            'Accept': 'application/vnd.github.v3+json'
        }
    });
    if (!response.ok) {
        throw new Error('Invalid token or repository. Please check your credentials.');
    }
    // Validate session settings
    const { sessionConfig } = settings;
    if (sessionConfig.idleThresholdMinutes < 1 || sessionConfig.idleThresholdMinutes > 60) {
        throw new Error('Idle threshold must be between 1 and 60 minutes');
    }
    if (sessionConfig.minSessionDurationSeconds < 1 || sessionConfig.minSessionDurationSeconds > 300) {
        throw new Error('Minimum session duration must be between 10 and 300 seconds');
    }
}
// Save settings
async function saveSettings(settings) {
    await chrome.storage.sync.set({
        githubRepo: settings.githubRepo,
        githubToken: settings.githubToken
    });
    await saveSessionConfig(settings.sessionConfig);
}
// Initialize options page
document.addEventListener('DOMContentLoaded', async () => {
    try {
        // Load current settings
        const [storageItems, sessionConfig] = await Promise.all([
            chrome.storage.sync.get(['githubRepo', 'githubToken']),
            loadSessionConfig()
        ]);
        // Combine settings and display them
        setFormValues({
            ...storageItems,
            sessionConfig
        });
        // Add save button handler
        const saveButton = document.getElementById('save');
        if (saveButton) {
            saveButton.addEventListener('click', async () => {
                try {
                    const settings = getFormValues();
                    await validateSettings(settings);
                    await saveSettings(settings);
                    showStatus('Settings saved successfully!');
                }
                catch (error) {
                    showStatus(`Error: ${error instanceof Error ? error.message : 'Unknown error'}`, true);
                }
            });
        }
    }
    catch (error) {
        showStatus(`Error loading settings: ${error instanceof Error ? error.message : 'Unknown error'}`, true);
    }
});
//# sourceMappingURL=options.bundle.js.map



---
File: extension/dist/popup.bundle.js
---
// extension/popup.ts
// Popup script with refactored manual paper tracking
console.log('Popup script starting...');
// Function to get paper data from background script
async function getCurrentPaper() {
    return new Promise((resolve) => {
        chrome.runtime.sendMessage({ type: 'getCurrentPaper' }, (response) => {
            console.log('Got paper data from background:', response);
            resolve(response);
        });
    });
}
// Function to update UI with paper data
function updateUI(paperData) {
    const titleElement = document.getElementById('paperTitle');
    const authorsElement = document.getElementById('paperAuthors');
    const statusElement = document.getElementById('status');
    const manualLogSection = document.getElementById('manualLogSection');
    if (!titleElement || !authorsElement || !statusElement || !manualLogSection) {
        console.error('Required DOM elements not found');
        return;
    }
    if (paperData) {
        // Show detected paper data
        titleElement.textContent = paperData.title || paperData.paperId;
        authorsElement.textContent = paperData.authors;
        statusElement.textContent = 'Paper tracked! Issue created on GitHub.';
        // Enable rating buttons
        const thumbsUpButton = document.getElementById('thumbsUp');
        const thumbsDownButton = document.getElementById('thumbsDown');
        if (thumbsUpButton && thumbsDownButton) {
            thumbsUpButton.disabled = false;
            thumbsDownButton.disabled = false;
            // Set active state on rating buttons
            thumbsUpButton.classList.toggle('active', paperData.rating === 'thumbsup');
            thumbsDownButton.classList.toggle('active', paperData.rating === 'thumbsdown');
        }
        // Hide manual log section
        manualLogSection.style.display = 'none';
    }
    else {
        // No paper detected - show manual log option
        titleElement.textContent = 'No paper detected';
        authorsElement.textContent = '';
        statusElement.textContent = 'Current page not recognized as a paper';
        // Disable rating buttons
        const thumbsUpButton = document.getElementById('thumbsUp');
        const thumbsDownButton = document.getElementById('thumbsDown');
        if (thumbsUpButton && thumbsDownButton) {
            thumbsUpButton.disabled = true;
            thumbsDownButton.disabled = true;
        }
        // Show manual log section
        manualLogSection.style.display = 'block';
    }
}
// Function to log current page as a paper (using content script extraction)
async function logCurrentPage() {
    console.log("attempting to log paper");
    // Get the active tab
    const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
    if (!tabs[0] || !tabs[0].id) {
        const statusElement = document.getElementById('status');
        if (statusElement) {
            statusElement.textContent = 'Error: Could not access current tab';
        }
        return;
    }
    // Show loading state
    const statusElement = document.getElementById('status');
    if (statusElement) {
        statusElement.textContent = 'Extracting paper metadata...';
    }
    // Send message to content script requesting extraction
    chrome.tabs.sendMessage(tabs[0].id, {
        type: 'extractPaperMetadata'
    }, (response) => {
        if (chrome.runtime.lastError) {
            // Handle error
            if (statusElement) {
                statusElement.textContent = 'Error: ' + chrome.runtime.lastError.message;
            }
            return;
        }
        if (!response || !response.success || !response.metadata) {
            // Handle extraction failure
            if (statusElement) {
                statusElement.textContent = 'Error: ' + (response?.error || 'Failed to extract metadata');
            }
            return;
        }
        // Success - update UI
        updateUI(response.metadata);
        if (statusElement) {
            statusElement.textContent = 'Paper tracked successfully!';
        }
        // The content script has already:
        // 1. Sent metadata to background script
        // 2. Started a session if the tab is visible
        // Hide manual log section
        const manualLogSection = document.getElementById('manualLogSection');
        if (manualLogSection) {
            manualLogSection.style.display = 'none';
        }
        // Enable rating buttons
        const thumbsUpButton = document.getElementById('thumbsUp');
        const thumbsDownButton = document.getElementById('thumbsDown');
        if (thumbsUpButton && thumbsDownButton) {
            thumbsUpButton.disabled = false;
            thumbsDownButton.disabled = false;
        }
    });
}
// Initialize popup
document.addEventListener('DOMContentLoaded', async () => {
    console.log('Popup opened');
    // Get paper from the session tracker
    let paperData = null;
    let retries = 3;
    while (retries > 0 && !paperData) {
        paperData = await getCurrentPaper();
        if (!paperData) {
            await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms before retry
            retries--;
        }
    }
    updateUI(paperData);
    // Set up rating handlers
    const thumbsUpButton = document.getElementById('thumbsUp');
    if (thumbsUpButton) {
        thumbsUpButton.addEventListener('click', () => {
            chrome.runtime.sendMessage({
                type: 'updateRating',
                rating: 'thumbsup'
            }, (response) => {
                const statusElement = document.getElementById('status');
                const thumbsUpButton = document.getElementById('thumbsUp');
                const thumbsDownButton = document.getElementById('thumbsDown');
                if (!statusElement || !thumbsUpButton || !thumbsDownButton)
                    return;
                if (response && response.success) {
                    statusElement.textContent = 'Rating updated to: thumbs up';
                    thumbsUpButton.classList.add('active');
                    thumbsDownButton.classList.remove('active');
                    setTimeout(() => window.close(), 1500);
                }
                else {
                    statusElement.textContent = 'Error: ' + (response?.error || 'Unknown error');
                }
            });
        });
    }
    const thumbsDownButton = document.getElementById('thumbsDown');
    if (thumbsDownButton) {
        thumbsDownButton.addEventListener('click', () => {
            chrome.runtime.sendMessage({
                type: 'updateRating',
                rating: 'thumbsdown'
            }, (response) => {
                const statusElement = document.getElementById('status');
                const thumbsUpButton = document.getElementById('thumbsUp');
                const thumbsDownButton = document.getElementById('thumbsDown');
                if (!statusElement || !thumbsUpButton || !thumbsDownButton)
                    return;
                if (response && response.success) {
                    statusElement.textContent = 'Rating updated to: thumbs down';
                    thumbsDownButton.classList.add('active');
                    thumbsUpButton.classList.remove('active');
                    setTimeout(() => window.close(), 1500);
                }
                else {
                    statusElement.textContent = 'Error: ' + (response?.error || 'Unknown error');
                }
            });
        });
    }
    // Set up one-click logging button
    const logPageButton = document.getElementById('logPageButton');
    if (logPageButton) {
        console.log("Attaching logPageButton event listener...");
        logPageButton.addEventListener('click', () => {
            console.log("logPageButton clicked...");
            logCurrentPage();
        });
    }
});
//# sourceMappingURL=popup.bundle.js.map



---
File: extension/manifest.json
---
{
  "manifest_version": 3,
  "name": "Academic Paper Tracker",
  "version": "2.0",
  "description": "Track and annotate academic papers from various sources",
  "permissions": [
    "tabs",
    "storage",
    "webNavigation",
    "scripting",
    "activeTab"
  ],
  "host_permissions": [
    "*://*.arxiv.org/*", 
    "*://export.arxiv.org/*",
    "*://api.github.com/*",
    "<all_urls>"
  ],
  "background": {
    "service_worker": "dist/background.bundle.js",
    "type": "module"
  },
  "content_scripts": [{
    "matches": ["<all_urls>"],
    "js": ["dist/content-script.js"],
    "run_at": "document_end",
    "type": "module"
  }],
  "action": {
    "default_popup": "popup.html"
  },
  "options_ui": {
    "page": "options.html",
    "open_in_tab": false
  }
}



---
File: extension/options.html
---
<!DOCTYPE html>
<html>
<head>
  <title>ArXiv Tracker Settings</title>
  <style>
    body {
      padding: 20px;
      font-family: system-ui, -apple-system, sans-serif;
    }
    .container {
      max-width: 500px;
      margin: 0 auto;
    }
    .field {
      margin-bottom: 20px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: 500;
    }
    input[type="text"],
    input[type="password"],
    input[type="number"] {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
    }
    input[type="number"] {
      width: 100px;
    }
    .help-text {
      font-size: 0.9em;
      color: #666;
      margin-top: 4px;
    }
    .status {
      margin-top: 16px;
      padding: 8px;
      border-radius: 4px;
    }
    .success {
      background: #e6ffe6;
      color: #006600;
    }
    .error {
      background: #ffe6e6;
      color: #660000;
    }
    button {
      background: #0366d6;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      margin-top: 16px;
    }
    button:hover {
      background: #0255b3;
    }
    .section {
      margin-bottom: 32px;
    }
    .section-title {
      font-size: 1.2em;
      font-weight: 600;
      margin-bottom: 16px;
      padding-bottom: 8px;
      border-bottom: 1px solid #eee;
    }
    .checkbox-field {
      margin-top: 12px;
    }
    .checkbox-field label {
      display: flex;
      align-items: center;
      font-weight: normal;
    }
    .checkbox-field input[type="checkbox"] {
      margin-right: 8px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h2>ArXiv Tracker Settings</h2>
    
    <div class="section">
      <div class="section-title">GitHub Integration</div>
      <div class="field">
        <label for="repo">GitHub Repository</label>
        <input type="text" id="repo" placeholder="username/repository">
        <div class="help-text">Format: username/repository (e.g., johndoe/arxiv-tracker)</div>
      </div>

      <div class="field">
        <label for="token">GitHub Personal Access Token</label>
        <input type="password" id="token" placeholder="ghp_xxxxxxxxxxxxxxxxxxxx">
        <div class="help-text">
          Token needs 'repo' scope for private repositories.<br>
          Never share this token with anyone.
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-title">Reading Session Settings</div>
      
      <div class="field">
        <label for="idleThreshold">Idle Threshold (minutes)</label>
        <input type="number" id="idleThreshold" min="1" max="60" value="5">
        <div class="help-text">
          Time of inactivity before session is paused (1-60 minutes).<br>
          Default: 5 minutes
        </div>
      </div>

      <div class="field">
        <label for="minDuration">Minimum Session Duration (seconds)</label>
        <input type="number" id="minDuration" min="10" max="300" value="30">
        <div class="help-text">
          Minimum time required to log a reading session (10-300 seconds).<br>
          Default: 30 seconds
        </div>
      </div>

      <div class="checkbox-field">
        <label>
          <input type="checkbox" id="requireContinuous">
          Require Continuous Activity
        </label>
        <div class="help-text">
          When enabled, resets the session timer if you're idle for too long.<br>
          Default: Enabled
        </div>
      </div>

      <div class="checkbox-field">
        <label>
          <input type="checkbox" id="logPartial">
          Log Partial Sessions
        </label>
        <div class="help-text">
          When enabled, logs sessions even if they're shorter than the minimum duration.<br>
          Default: Disabled
        </div>
      </div>
    </div>

    <button id="save">Save Settings</button>
    <div id="status" class="status"></div>
  </div>
  <script type="module" src="dist/options.bundle.js"></script>
</body>
</html>



---
File: extension/options.ts
---
// options.ts
import { loadSessionConfig, DEFAULT_CONFIG, saveSessionConfig } from './config/session';
import { RawSessionConfig } from './config/types';

// Helper to set form values
function setFormValues(settings: {
  githubRepo?: string;
  githubToken?: string;
  sessionConfig?: RawSessionConfig;
}): void {
  // GitHub settings
  if (settings.githubRepo) {
    (document.getElementById('repo') as HTMLInputElement).value = settings.githubRepo;
  }
  if (settings.githubToken) {
    // Don't show the actual token, just indicate it's set
    (document.getElementById('token') as HTMLInputElement).placeholder = 'â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢';
  }

  // Session settings
  (document.getElementById('idleThreshold') as HTMLInputElement).value = 
    String(settings.sessionConfig?.idleThresholdMinutes ?? DEFAULT_CONFIG.idleThresholdMinutes);
    
  (document.getElementById('minDuration') as HTMLInputElement).value = 
    String(settings.sessionConfig?.minSessionDurationSeconds ?? DEFAULT_CONFIG.minSessionDurationSeconds);
    
  (document.getElementById('requireContinuous') as HTMLInputElement).checked = 
    settings.sessionConfig?.requireContinuousActivity ?? DEFAULT_CONFIG.requireContinuousActivity;
    
  (document.getElementById('logPartial') as HTMLInputElement).checked = 
    settings.sessionConfig?.logPartialSessions ?? DEFAULT_CONFIG.logPartialSessions;
}

// Helper to get form values
function getFormValues(): {
  githubRepo: string;
  githubToken: string;
  sessionConfig: RawSessionConfig;
} {
  return {
    githubRepo: (document.getElementById('repo') as HTMLInputElement).value.trim(),
    githubToken: (document.getElementById('token') as HTMLInputElement).value.trim(),
    sessionConfig: {
      idleThresholdMinutes: Number((document.getElementById('idleThreshold') as HTMLInputElement).value),
      minSessionDurationSeconds: Number((document.getElementById('minDuration') as HTMLInputElement).value),
      requireContinuousActivity: (document.getElementById('requireContinuous') as HTMLInputElement).checked,
      logPartialSessions: (document.getElementById('logPartial') as HTMLInputElement).checked,
      activityUpdateIntervalSeconds: DEFAULT_CONFIG.activityUpdateIntervalSeconds // Keep default
    }
  };
}

// Display status message
function showStatus(message: string, isError = false): void {
  const status = document.getElementById('status');
  if (!status) return;
  
  status.textContent = message;
  status.className = `status ${isError ? 'error' : 'success'}`;

  // Clear status after 3 seconds if it's a success message
  if (!isError) {
    setTimeout(() => {
      if (status) {
        status.textContent = '';
        status.className = 'status';
      }
    }, 3000);
  }
}

// Validate settings before saving
async function validateSettings(settings: {
  githubRepo: string;
  githubToken: string;
  sessionConfig: RawSessionConfig;
}): Promise<void> {
  // Validate repository format
  if (!/^[\w-]+\/[\w-]+$/.test(settings.githubRepo)) {
    throw new Error('Invalid repository format. Use username/repository');
  }

  // Validate the token by making a test API call
  const response = await fetch(`https://api.github.com/repos/${settings.githubRepo}`, {
    headers: {
      'Authorization': `token ${settings.githubToken}`,
      'Accept': 'application/vnd.github.v3+json'
    }
  });

  if (!response.ok) {
    throw new Error('Invalid token or repository. Please check your credentials.');
  }

  // Validate session settings
  const { sessionConfig } = settings;
  if (sessionConfig.idleThresholdMinutes < 1 || sessionConfig.idleThresholdMinutes > 60) {
    throw new Error('Idle threshold must be between 1 and 60 minutes');
  }
  if (sessionConfig.minSessionDurationSeconds < 1 || sessionConfig.minSessionDurationSeconds > 300) {
    throw new Error('Minimum session duration must be between 10 and 300 seconds');
  }
}

// Save settings
async function saveSettings(settings: {
  githubRepo: string;
  githubToken: string;
  sessionConfig: RawSessionConfig;
}): Promise<void> {
  await chrome.storage.sync.set({
    githubRepo: settings.githubRepo,
    githubToken: settings.githubToken
  });

  await saveSessionConfig(settings.sessionConfig);
}

// Initialize options page
document.addEventListener('DOMContentLoaded', async () => {
  try {
    // Load current settings
    const [storageItems, sessionConfig] = await Promise.all([
      chrome.storage.sync.get(['githubRepo', 'githubToken']),
      loadSessionConfig()
    ]);

    // Combine settings and display them
    setFormValues({
      ...(storageItems as {
        githubRepo?: string;
        githubToken?: string;
      }),
      sessionConfig
    });

    // Add save button handler
    const saveButton = document.getElementById('save');
    if (saveButton) {
      saveButton.addEventListener('click', async () => {
        try {
          const settings = getFormValues();
          await validateSettings(settings);
          await saveSettings(settings);
          showStatus('Settings saved successfully!');
        } catch (error) {
          showStatus(`Error: ${error instanceof Error ? error.message : 'Unknown error'}`, true);
        }
      });
    }

  } catch (error) {
    showStatus(`Error loading settings: ${error instanceof Error ? error.message : 'Unknown error'}`, true);
  }
});



---
File: extension/package.json
---
{
  "name": "arxiv-tracker-extension",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "build": "rollup -c",
    "watch": "rollup -c -w",
    "type-check": "tsc --noEmit",
    "lint": "eslint . --ext .ts",
    "format": "prettier --write \"**/*.{ts,js}\"",
    "clean": "rm -rf dist"
  },
  "dependencies": {
    "gh-store-client": "^0.11.1"
  },
  "devDependencies": {
    "@rollup/plugin-commonjs": "^22.0.0",
    "@rollup/plugin-node-resolve": "^13.3.0",
    "@rollup/plugin-typescript": "^8.3.2",
    "@types/chrome": "^0.0.246",
    "@types/node": "^20.10.6",
    "@typescript-eslint/eslint-plugin": "^6.17.0",
    "@typescript-eslint/parser": "^6.17.0",
    "eslint": "^8.56.0",
    "prettier": "^3.1.1",
    "rollup": "^2.75.6",
    "rollup-plugin-terser": "^7.0.2",
    "tslib": "^2.4.0",
    "typescript": "^5.3.3"
  }
}



---
File: extension/papers/debug.d.ts
---
// extension/papers/debug.d.ts
import { GitHubStoreClient } from 'gh-store-client';
import { PaperManager } from './manager';

declare global {
    const __DEBUG__: {
        paperManager: PaperManager | null;
        getGithubClient: () => GitHubStoreClient | undefined;
        getCurrentPaper: () => any;
        getCurrentSession: () => any;
        getConfig: () => any;
    }
}



---
File: extension/papers/manager.ts
---
// extension/papers/manager.ts
import { GitHubStoreClient } from 'gh-store-client';
import type { Json } from 'gh-store-client';
import { 
  type PaperMetadata, 
  type InteractionLog, 
  type Interaction,
  type ReadingSessionData,
  isInteractionLog
} from './types';
import { SourceManager } from '../source-integration/types';
import { loguru } from '../utils/logger';

const logger = loguru.getLogger('paper-manager');

export class PaperManager {
  constructor(
    private client: GitHubStoreClient,
    private sourceManager: SourceManager
  ) {
    logger.debug('Paper manager initialized');
  }
  
  /**
   * Get paper by source and ID
   */
  async getPaper(sourceId: string, paperId: string): Promise<PaperMetadata | null> {
    const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
    
    try {
      const obj = await this.client.getObject(objectId);
      return obj.data as PaperMetadata;
    } catch (error) {
      if (error instanceof Error && error.message.includes('No object found')) {
        return null;
      }
      throw error;
    }
  }
  
  /**
   * Get or create paper metadata
   */
  async getOrCreatePaper(paperData: PaperMetadata): Promise<PaperMetadata> {
    const { sourceId, paperId } = paperData;
    const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
    const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
    
    try {
      const obj = await this.client.getObject(objectId);
      const data = obj.data as PaperMetadata;
      logger.debug(`Retrieved existing paper: ${paperIdentifier}`);
      return data;
    } catch (error) {
      if (error instanceof Error && error.message.includes('No object found')) {
        // Create new paper
        const defaultPaperData: PaperMetadata = {
          ...paperData,
          timestamp: new Date().toISOString(),
          rating: paperData.rating || 'novote'
        };

        const newobj = await this.client.createObject(objectId, defaultPaperData, ["TODO:hydrate-metadata"]);
        logger.debug(`Created new paper: ${paperIdentifier}`);
        // reopen to trigger metadata hydration
        await this.client.fetchFromGitHub(`/issues/${newobj.meta.issueNumber}`, {
          method: "PATCH",
          body: JSON.stringify({ state: "open" })
        });
        return defaultPaperData;
      }
      throw error;
    }
  }

  /**
   * Get or create interaction log for a paper
   */
  private async getOrCreateInteractionLog(sourceId: string, paperId: string): Promise<InteractionLog> {
    const objectId = this.sourceManager.formatObjectId('interactions', sourceId, paperId);
    const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
    
    try {
      const obj = await this.client.getObject(objectId);
      const data = obj.data as unknown;
      if (isInteractionLog(data)) {
        return data;
      }
      throw new Error('Invalid interaction log format');
    } catch (error) {
      if (error instanceof Error && error.message.includes('No object found')) {
        const newLog: InteractionLog = {
          sourceId,
          paperId,
          interactions: []
        };
        await this.client.createObject(objectId, newLog as unknown as { [key: string]: Json });
        logger.debug(`Created new interaction log: ${paperIdentifier}`);
        return newLog;
      }
      throw error;
    }
  }
  
  /**
   * Get GitHub client instance
   */
  getClient(): GitHubStoreClient {
    return this.client;
  }
  
  /**
   * Log a reading session
   */
  async logReadingSession(
    sourceId: string,
    paperId: string,
    session: ReadingSessionData,
    paperData?: Partial<PaperMetadata>
  ): Promise<void> {
    // Ensure paper exists
    if (paperData) {
      await this.getOrCreatePaper({
        sourceId,
        paperId,
        url: paperData.url || this.sourceManager.formatPaperId(sourceId, paperId),
        title: paperData.title || paperId,
        authors: paperData.authors || '',
        abstract: paperData.abstract || '',
        timestamp: new Date().toISOString(),
        rating: 'novote',
        publishedDate: paperData.publishedDate || '',
        tags: paperData.tags || []
      });
    }

    // Log the session as an interaction
    await this.addInteraction(sourceId, paperId, {
      type: 'reading_session',
      timestamp: new Date().toISOString(),
      data: session as unknown as { [key: string]: Json }
    });
    
    const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
    logger.info(`Logged reading session for ${paperIdentifier}`, { duration: session.duration_seconds });
  }

  /**
   * Log an annotation
   */
  async logAnnotation(
    sourceId: string,
    paperId: string,
    key: string,
    value: Json,
    paperData?: Partial<PaperMetadata>
  ): Promise<void> {
    // Ensure paper exists
    if (paperData) {
      await this.getOrCreatePaper({
        sourceId,
        paperId,
        url: paperData.url || this.sourceManager.formatPaperId(sourceId, paperId),
        title: paperData.title || paperId,
        authors: paperData.authors || '',
        abstract: paperData.abstract || '',
        timestamp: new Date().toISOString(),
        rating: 'novote',
        publishedDate: paperData.publishedDate || '',
        tags: paperData.tags || []
      });
    }

    // Log the annotation as an interaction
    await this.addInteraction(sourceId, paperId, {
      type: 'annotation',
      timestamp: new Date().toISOString(),
      data: { key, value }
    });
    
    const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
    logger.info(`Logged annotation for ${paperIdentifier}`, { key });
  }

  /**
   * Update paper rating
   */
  async updateRating(
    sourceId: string,
    paperId: string,
    rating: string,
    paperData?: Partial<PaperMetadata>
  ): Promise<void> {
    // Ensure paper exists and get current data
    const paper = await this.getOrCreatePaper({
      sourceId,
      paperId,
      url: paperData?.url || this.sourceManager.formatPaperId(sourceId, paperId),
      title: paperData?.title || paperId,
      authors: paperData?.authors || '',
      abstract: paperData?.abstract || '',
      timestamp: new Date().toISOString(),
      rating: 'novote',
      publishedDate: paperData?.publishedDate || '',
      tags: paperData?.tags || []
    });

    const objectId = this.sourceManager.formatObjectId('paper', sourceId, paperId);
    
    // Update paper metadata with new rating
    await this.client.updateObject(objectId, { 
      ...paper,
      rating 
    });

    // Log rating change as an interaction
    await this.addInteraction(sourceId, paperId, {
      type: 'rating',
      timestamp: new Date().toISOString(),
      data: { rating }
    });
    
    const paperIdentifier = this.sourceManager.formatPaperId(sourceId, paperId);
    logger.info(`Updated rating for ${paperIdentifier} to ${rating}`);
  }

  /**
   * Add interaction to log
   */
  private async addInteraction(sourceId: string, paperId: string, interaction: Interaction): Promise<void> {
    const log = await this.getOrCreateInteractionLog(sourceId, paperId);
    log.interactions.push(interaction);
    
    const objectId = this.sourceManager.formatObjectId('interactions', sourceId, paperId);
    await this.client.updateObject(objectId, log as unknown as { [key: string]: Json });
  }
}



---
File: extension/papers/types.ts
---
// extension/papers/types.ts
// Updated for heartbeat-based session tracking

import type { Json } from 'gh-store-client';

/**
 * Paper metadata from any source
 */
export interface PaperMetadata {
  // Source identifier
  sourceId: string;
  
  // Paper identifier within the source
  paperId: string;
  
  // Full URL to the paper
  url: string;
  
  // Paper title
  title: string;
  
  // Authors (comma-separated)
  authors: string;
  
  // Abstract or summary
  abstract: string;
  
  // When this paper was first added
  timestamp: string;
  
  // Publication date
  publishedDate: string;
  
  // Tags or categories
  tags: string[];
  
  // User-assigned rating (novote, thumbsup, thumbsdown)
  rating: string;
  
  // Allow additional source-specific properties
  [key: string]: any;
}

/**
 * Reading session data - updated for heartbeat tracking
 */
export interface ReadingSessionData {
  // Session identifier
  session_id: string;
  
  // Paper identifiers
  source_id?: string;
  paper_id?: string;
  
  // Session timing
  start_time: string;
  end_time: string;
  
  // Heartbeat data
  heartbeat_count: number;
  
  // Duration in seconds (derived from heartbeat count)
  duration_seconds: number;
  
  // Legacy properties for backward compatibility
  idle_seconds?: number;
  total_elapsed_seconds?: number;
}

/**
 * Interaction data
 */
export interface Interaction {
  // Type of interaction (reading_session, annotation, rating)
  type: string;
  
  // When interaction occurred
  timestamp: string;
  
  // Additional data
  data: Json;
}

/**
 * Interaction log
 */
export interface InteractionLog {
  // Source identifier
  sourceId: string;
  
  // Paper identifier within the source
  paperId: string;
  
  // List of interactions
  interactions: Interaction[];

  // Index signature to make it compatible with Json type
  [key: string]: string | Interaction[] | any;
}

/**
 * Type guard for interaction log
 */
export function isInteractionLog(data: unknown): data is InteractionLog {
  const log = data as InteractionLog;
  return (
    typeof log === 'object' &&
    log !== null &&
    typeof log.sourceId === 'string' &&
    typeof log.paperId === 'string' &&
    Array.isArray(log.interactions)
  );
}



---
File: extension/popup.html
---
<!DOCTYPE html>
<html>
<head>
  <style>
    body {
      width: 400px;
      padding: 15px;
      font-family: system-ui, -apple-system, sans-serif;
    }
    .paper-info {
      margin-bottom: 15px;
    }
    .paper-title {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 14px;
      line-height: 1.4;
    }
    .paper-authors {
      font-size: 12px;
      color: #666;
      margin-bottom: 12px;
      line-height: 1.4;
    }
    .rating-buttons {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    button {
      flex: 1;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f5f5f5;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    button:not(:disabled):hover {
      background: #e5e5e5;
    }
    .status {
      margin-top: 10px;
      font-size: 12px;
      color: #666;
      padding: 8px;
      background: #f5f5f5;
      border-radius: 4px;
      text-align: center;
    }
    /* New styles for manual logging UI */
    .manual-log-section {
      margin-top: 20px;
      padding-top: 15px;
      border-top: 1px solid #eee;
      display: none; /* Hidden by default, shown when no paper detected */
    }
    .manual-log-section h3 {
      font-size: 14px;
      margin-top: 0;
      margin-bottom: 10px;
    }
    .log-button {
      width: 100%;
      padding: 10px;
      background: #2563eb;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      margin-bottom: 10px;
    }
    .log-button:hover {
      background: #1d4ed8;
    }
  </style>
</head>
<body>
  <div id="currentPaper" class="paper-info">
    <div id="paperTitle" class="paper-title">Loading...</div>
    <div id="paperAuthors" class="paper-authors"></div>
    <div class="rating-buttons">
      <button id="thumbsUp" disabled>ðŸ‘ Interesting</button>
      <button id="thumbsDown" disabled>ðŸ‘Ž Not Relevant</button>
    </div>
    <div id="status" class="status">Loading paper details...</div>
  </div>
  
  <!-- New section for manually logging a paper with one-click -->
  <div id="manualLogSection" class="manual-log-section">
    <h3>This page is not tracked as a paper</h3>
    <button id="logPageButton" class="log-button">Track This Page</button>
  </div>
  
  <script src="dist/popup.bundle.js"></script>
</body>
</html>



---
File: extension/popup.ts
---
// extension/popup.ts
// Popup script with refactored manual paper tracking

import { PaperMetadata } from './papers/types';

console.log('Popup script starting...');

// Function to get paper data from background script
async function getCurrentPaper(): Promise<PaperMetadata | null> {
  return new Promise((resolve) => {
    chrome.runtime.sendMessage({type: 'getCurrentPaper'}, (response) => {
      console.log('Got paper data from background:', response);
      resolve(response as PaperMetadata | null);
    });
  });
}

// Interface for message response
interface MessageResponse {
  success: boolean;
  error?: string;
  metadata?: PaperMetadata;
}

// Function to update UI with paper data
function updateUI(paperData: PaperMetadata | null): void {
  const titleElement = document.getElementById('paperTitle');
  const authorsElement = document.getElementById('paperAuthors');
  const statusElement = document.getElementById('status');
  const manualLogSection = document.getElementById('manualLogSection');

  if (!titleElement || !authorsElement || !statusElement || !manualLogSection) {
    console.error('Required DOM elements not found');
    return;
  }

  if (paperData) {
    // Show detected paper data
    titleElement.textContent = paperData.title || paperData.paperId;
    authorsElement.textContent = paperData.authors;
    statusElement.textContent = 'Paper tracked! Issue created on GitHub.';
    
    // Enable rating buttons
    const thumbsUpButton = document.getElementById('thumbsUp') as HTMLButtonElement;
    const thumbsDownButton = document.getElementById('thumbsDown') as HTMLButtonElement;
    
    if (thumbsUpButton && thumbsDownButton) {
      thumbsUpButton.disabled = false;
      thumbsDownButton.disabled = false;
      
      // Set active state on rating buttons
      thumbsUpButton.classList.toggle('active', paperData.rating === 'thumbsup');
      thumbsDownButton.classList.toggle('active', paperData.rating === 'thumbsdown');
    }
    
    // Hide manual log section
    manualLogSection.style.display = 'none';
  } else {
    // No paper detected - show manual log option
    titleElement.textContent = 'No paper detected';
    authorsElement.textContent = '';
    statusElement.textContent = 'Current page not recognized as a paper';
    
    // Disable rating buttons
    const thumbsUpButton = document.getElementById('thumbsUp') as HTMLButtonElement;
    const thumbsDownButton = document.getElementById('thumbsDown') as HTMLButtonElement;
    
    if (thumbsUpButton && thumbsDownButton) {
      thumbsUpButton.disabled = true;
      thumbsDownButton.disabled = true;
    }
    
    // Show manual log section
    manualLogSection.style.display = 'block';
  }
}

// Function to log current page as a paper (using content script extraction)
async function logCurrentPage(): Promise<void> {
  console.log("attempting to log paper");
  
  // Get the active tab
  const tabs = await chrome.tabs.query({ active: true, currentWindow: true });
  if (!tabs[0] || !tabs[0].id) {
    const statusElement = document.getElementById('status');
    if (statusElement) {
      statusElement.textContent = 'Error: Could not access current tab';
    }
    return;
  }
  
  // Show loading state
  const statusElement = document.getElementById('status');
  if (statusElement) {
    statusElement.textContent = 'Extracting paper metadata...';
  }
  
  // Send message to content script requesting extraction
  chrome.tabs.sendMessage(tabs[0].id, { 
    type: 'extractPaperMetadata' 
  }, (response: MessageResponse) => {
    if (chrome.runtime.lastError) {
      // Handle error
      if (statusElement) {
        statusElement.textContent = 'Error: ' + chrome.runtime.lastError.message;
      }
      return;
    }
    
    if (!response || !response.success || !response.metadata) {
      // Handle extraction failure
      if (statusElement) {
        statusElement.textContent = 'Error: ' + (response?.error || 'Failed to extract metadata');
      }
      return;
    }
    
    // Success - update UI
    updateUI(response.metadata);
    if (statusElement) {
      statusElement.textContent = 'Paper tracked successfully!';
    }
    
    // The content script has already:
    // 1. Sent metadata to background script
    // 2. Started a session if the tab is visible
    
    // Hide manual log section
    const manualLogSection = document.getElementById('manualLogSection');
    if (manualLogSection) {
      manualLogSection.style.display = 'none';
    }
    
    // Enable rating buttons
    const thumbsUpButton = document.getElementById('thumbsUp') as HTMLButtonElement;
    const thumbsDownButton = document.getElementById('thumbsDown') as HTMLButtonElement;
    if (thumbsUpButton && thumbsDownButton) {
      thumbsUpButton.disabled = false;
      thumbsDownButton.disabled = false;
    }
  });
}

// Initialize popup
document.addEventListener('DOMContentLoaded', async () => {
  console.log('Popup opened');
  
  // Get paper from the session tracker
  let paperData: PaperMetadata | null = null;
  let retries = 3;
  
  while (retries > 0 && !paperData) {
    paperData = await getCurrentPaper();
    if (!paperData) {
      await new Promise(resolve => setTimeout(resolve, 500)); // Wait 500ms before retry
      retries--;
    }
  }
  
  updateUI(paperData);
  
  // Set up rating handlers
  const thumbsUpButton = document.getElementById('thumbsUp');
  if (thumbsUpButton) {
    thumbsUpButton.addEventListener('click', () => {
      chrome.runtime.sendMessage({
        type: 'updateRating',
        rating: 'thumbsup'
      }, (response: MessageResponse) => {
        const statusElement = document.getElementById('status');
        const thumbsUpButton = document.getElementById('thumbsUp');
        const thumbsDownButton = document.getElementById('thumbsDown');
        
        if (!statusElement || !thumbsUpButton || !thumbsDownButton) return;
        
        if (response && response.success) {
          statusElement.textContent = 'Rating updated to: thumbs up';
          thumbsUpButton.classList.add('active');
          thumbsDownButton.classList.remove('active');
          setTimeout(() => window.close(), 1500);
        } else {
          statusElement.textContent = 'Error: ' + (response?.error || 'Unknown error');
        }
      });
    });
  }
  
  const thumbsDownButton = document.getElementById('thumbsDown');
  if (thumbsDownButton) {
    thumbsDownButton.addEventListener('click', () => {
      chrome.runtime.sendMessage({
        type: 'updateRating',
        rating: 'thumbsdown'
      }, (response: MessageResponse) => {
        const statusElement = document.getElementById('status');
        const thumbsUpButton = document.getElementById('thumbsUp');
        const thumbsDownButton = document.getElementById('thumbsDown');
        
        if (!statusElement || !thumbsUpButton || !thumbsDownButton) return;
        
        if (response && response.success) {
          statusElement.textContent = 'Rating updated to: thumbs down';
          thumbsDownButton.classList.add('active');
          thumbsUpButton.classList.remove('active');
          setTimeout(() => window.close(), 1500);
        } else {
          statusElement.textContent = 'Error: ' + (response?.error || 'Unknown error');
        }
      });
    });
  }
  
  // Set up one-click logging button
  const logPageButton = document.getElementById('logPageButton');
  if (logPageButton) {
    console.log("Attaching logPageButton event listener...");
    logPageButton.addEventListener('click', () => {
      console.log("logPageButton clicked...");
      logCurrentPage();
    });
  }
});



---
File: extension/rollup.config.js
---
// rollup.config.js
import typescript from '@rollup/plugin-typescript';
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import { terser } from 'rollup-plugin-terser';

export default [
  // Background script as ESM (module)
  {
    input: 'background.ts',
    output: {
      file: 'dist/background.bundle.js',
      format: 'es',
      sourcemap: true
    },
    plugins: [
      typescript(),
      resolve(),
      commonjs()
    ]
  },
  // Content script as IIFE (non-module)
  {
    input: 'content.ts',
    output: {
      file: 'dist/content-script.js',
      format: 'iife', // Immediately-invoked function expression - no imports needed
      sourcemap: true
    },
    plugins: [
      typescript(),
      resolve(),
      commonjs(),
      terser() // Minify for production (optional)
    ]
  },
  // Options script
  {
    input: 'options.ts',
    output: {
      file: 'dist/options.bundle.js',
      format: 'es',
      sourcemap: true
    },
    plugins: [
      typescript(),
      resolve(),
      commonjs()
    ]
  },
  // Popup script - converted to TypeScript
  {
    input: 'popup.ts',
    output: {
      file: 'dist/popup.bundle.js',
      format: 'es',
      sourcemap: true
    },
    plugins: [
      typescript(),
      resolve(),
      commonjs()
    ]
  }
];



---
File: extension/source-integration/arxiv/index.ts
---
// extension/source-integration/arxiv/index.ts
// ArXiv integration with custom metadata extractor

import { BaseSourceIntegration } from '../base-source';
import { PaperMetadata } from '../../papers/types';
import { MetadataExtractor, createMetadataExtractor } from '../../utils/metadata-extractor';
import { loguru } from '../../utils/logger';

const logger = loguru.getLogger('arxiv-integration');


/**
 * ArXiv integration with custom metadata extraction
 */
export class ArXivIntegration extends BaseSourceIntegration {
  readonly id = 'arxiv';
  readonly name = 'arXiv.org';
  
  // URL patterns for papers
  readonly urlPatterns = [
    /arxiv\.org\/(abs|pdf|html)\/([0-9.]+)/,
    /arxiv\.org\/\w+\/([0-9.]+)/
  ];
  
  // Content script matches
  readonly contentScriptMatches = [
    "*://*.arxiv.org/*"
  ];

  /**
   * Extract paper ID from URL
   */
  extractPaperId(url: string): string | null {
    for (const pattern of this.urlPatterns) {
      const match = url.match(pattern);
      if (match) {
        return match[2] || match[1]; // The capture group with the paper ID
      }
    }
    return null;
  }

  /**
   * Extract metadata from page or fetch from API
   * Override parent method to handle the API fallback
   */
  async extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null> {
    logger.info(`Extracting metadata for arXiv ID: ${paperId}`);
    
    // Try to extract from page first using our custom extractor
    const pageMetadata = await super.extractMetadata(document, paperId);
    
    // if (pageMetadata && pageMetadata.title && pageMetadata.authors) {
    logger.debug('Extracted metadata from page');
    return pageMetadata;
    // }
    
  }
}

// Export a singleton instance that can be used by both background and content scripts
export const arxivIntegration = new ArXivIntegration();



---
File: extension/source-integration/base-source.ts
---
// extension/source-integration/base-source.ts
// Base class for source integrations with default identifier formatting
// and metadata extraction capability

import { SourceIntegration } from './types';
import { PaperMetadata } from '../papers/types';
import { loguru } from '../utils/logger';
import { 
  MetadataExtractor, 
  createMetadataExtractor,
  generatePaperIdFromUrl
} from '../utils/metadata-extractor';

const logger = loguru.getLogger('base-source');

/**
 * Base class for source integrations
 * Provides default implementations for all methods
 * Specific sources can override as needed
 */
export class BaseSourceIntegration implements SourceIntegration {
  // Default properties - set for generic web pages
  readonly id: string = 'url';
  readonly name: string = 'Web Page';
  readonly urlPatterns: RegExp[] = [
    /^https?:\/\/(?!.*\.pdf($|\?|#)).*$/i  // Match HTTP/HTTPS URLs that aren't PDFs
  ];
  readonly contentScriptMatches: string[] = [];

  /**
   * Check if this integration can handle the given URL
   * Default implementation checks against urlPatterns
   */
  canHandleUrl(url: string): boolean {
    return this.urlPatterns.some(pattern => pattern.test(url));
  }

  /**
   * Extract paper ID from URL
   * Default implementation creates a hash from the URL
   */
  extractPaperId(url: string): string | null {
    return generatePaperIdFromUrl(url);
  }
  
  /**
   * Create a metadata extractor for the given document
   * Override this method to provide a custom extractor for your source
   */
  protected createMetadataExtractor(document: Document): MetadataExtractor {
    return createMetadataExtractor(document);
  }
  
  /**
   * Extract metadata from a page
   * Default implementation uses common metadata extraction
   */
  async extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null> {
    try {
      logger.debug(`Extracting metadata using base extractor for ID: ${paperId}`);
      
      // Create a metadata extractor for this document
      const extractor = this.createMetadataExtractor(document);
      
      // Extract metadata
      const extracted = extractor.extract();
      const url = document.location.href;
      
      // Determine source type (PDF or URL)
      const sourceType = extractor.getSourceType();
      
      // Create PaperMetadata object
      return {
        sourceId: this.id,
        //paperId: this.formatPaperId(paperId),
        paperId: paperId,
        url: url,
        title: extracted.title || document.title || paperId,
        authors: extracted.authors || '',
        abstract: extracted.description || '',
        timestamp: new Date().toISOString(),
        rating: 'novote',
        publishedDate: extracted.publishedDate || '',
        tags: extracted.tags || [],
        doi: extracted.doi,
        journalName: extracted.journalName,
        sourceType: sourceType // Store the source type for reference
      };
    } catch (error) {
      logger.error('Error extracting metadata with base extractor', error);
      return null;
    }
  }
  
  /**
   * Format a paper identifier for this source
   * Default implementation uses the format: sourceId.paperId
   */
  formatPaperId(paperId: string): string {
    return `${this.id}.${paperId}`;
  }
  
  /**
   * Parse a paper identifier specific to this source
   * Default implementation handles source.paperId format and extracts paperId
   */
  parsePaperId(identifier: string): string | null {
    const prefix = `${this.id}.`;
    
    if (identifier.startsWith(prefix)) {
      return identifier.substring(prefix.length);
    }
    
    // Try legacy format (sourceId:paperId)
    const legacyPrefix = `${this.id}:`;
    if (identifier.startsWith(legacyPrefix)) {
      logger.debug(`Parsed legacy format identifier: ${identifier}`);
      return identifier.substring(legacyPrefix.length);
    }
    
    return null;
  }
  
  /**
   * Format a storage object ID for this source
   * Default implementation uses the format: type:sourceId.paperId
   */
  formatObjectId(type: string, paperId: string): string {
    return `${type}:${this.formatPaperId(paperId)}`;
  }
}



---
File: extension/source-integration/index.ts
---
// extension/source-integration/index.ts
// Create a barrel file to export all source integrations

import { arxivIntegration } from './arxiv';

// Export all available integrations
export const availableIntegrations = [
  arxivIntegration,
];

// Export individual integrations
export {
  arxivIntegration,
};



---
File: extension/source-integration/link-processor.ts
---
// extension/source-integration/link-processor.ts
// Generic link detection and processing module

import { loguru } from '../utils/logger';

const logger = loguru.getLogger('link-processor');

interface LinkPattern {
  // Source integration ID
  sourceId: string;
  
  // Regular expression to match URLs
  pattern: RegExp;
  
  // Function to extract paper ID from URL
  extractPaperId: (url: string) => string | null;
}

export class LinkProcessor {
  private patterns: LinkPattern[] = [];
  private observer: MutationObserver | null = null;
  private processedLinks = new Set<string>();
  private onLinkFound: (sourceId: string, paperId: string, link: HTMLAnchorElement) => void;
  
  constructor(onLinkFound: (sourceId: string, paperId: string, link: HTMLAnchorElement) => void) {
    this.onLinkFound = onLinkFound;
    logger.debug('Link processor initialized');
  }
  
  /**
   * Register a new link pattern
   */
  registerPattern(pattern: LinkPattern): void {
    this.patterns.push(pattern);
    logger.debug(`Registered pattern for ${pattern.sourceId}`);
  }
  
  /**
   * Process all links in the document
   */
  processLinks(document: Document): void {
    // Process all links in the document
    const links = document.querySelectorAll<HTMLAnchorElement>('a[href]');
    
    links.forEach(link => {
      // Use a unique identifier for this link
      const linkId = this.getLinkId(link);
      
      // Skip if already processed
      if (this.processedLinks.has(linkId)) {
        return;
      }
      
      this.processedLinks.add(linkId);
      
      // Check each pattern
      for (const pattern of this.patterns) {
        if (pattern.pattern.test(link.href)) {
          const paperId = pattern.extractPaperId(link.href);
          
          if (paperId) {
            // Call the callback
            this.onLinkFound(pattern.sourceId, paperId, link);
            break; // Stop after first match
          }
        }
      }
    });
  }
  
  /**
   * Start observing for DOM changes
   */
  startObserving(document: Document): void {
    if (this.observer) {
      this.observer.disconnect();
    }
    
    this.observer = new MutationObserver((mutations) => {
      let newLinks = false;
      
      mutations.forEach(mutation => {
        mutation.addedNodes.forEach(node => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            // If this is an anchor tag, check it
            if ((node as Element).tagName === 'A') {
              newLinks = true;
            }
            
            // Check for any anchor tags within this element
            const links = (node as Element).querySelectorAll('a[href]');
            if (links.length > 0) {
              newLinks = true;
            }
          }
        });
      });
      
      if (newLinks) {
        this.processLinks(document);
      }
    });
    
    this.observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    
    logger.debug('Started observing for DOM changes');
  }
  
  /**
   * Create a unique ID for a link
   */
  private getLinkId(link: HTMLAnchorElement): string {
    // Use href and position in document to create a unique ID
    const path = this.getElementPath(link);
    return `${link.href}|${path}`;
  }
  
  /**
   * Get element path in DOM for identification
   */
  private getElementPath(element: Element): string {
    const path: string[] = [];
    let current: Element | null = element;
    
    while (current && current !== document.body) {
      let selector = current.tagName.toLowerCase();
      
      if (current.id) {
        selector += `#${current.id}`;
      } else {
        const siblings = Array.from(current.parentElement?.children || []);
        const index = siblings.indexOf(current) + 1;
        if (siblings.length > 1) {
          selector += `:nth-child(${index})`;
        }
      }
      
      path.unshift(selector);
      current = current.parentElement;
    }
    
    return path.join(' > ');
  }
  
  /**
   * Stop observing DOM changes
   */
  stopObserving(): void {
    if (this.observer) {
      this.observer.disconnect();
      this.observer = null;
      logger.debug('Stopped observing DOM changes');
    }
  }
}



---
File: extension/source-integration/source-manager.ts
---
// extension/source-integration/source-manager.ts
// Updated SourceIntegrationManager to use source-specific identifier formatting

import { SourceIntegration, SourceManager } from './types';
import { loguru } from '../utils/logger';

const logger = loguru.getLogger('source-manager');

/**
 * Manages source integrations
 */
export class SourceIntegrationManager implements SourceManager {
  private sources: Map<string, SourceIntegration> = new Map();
  
  constructor() {
    logger.info('Source integration manager initialized');
  }
  
  /**
   * Register a source integration
   */
  registerSource(source: SourceIntegration): void {
    if (this.sources.has(source.id)) {
      logger.warning(`Source with ID '${source.id}' already registered, overwriting`);
    }
    
    this.sources.set(source.id, source);
    logger.info(`Registered source: ${source.name} (${source.id})`);
  }
  
  /**
   * Get all registered sources
   */
  getAllSources(): SourceIntegration[] {
    return Array.from(this.sources.values());
  }
  
  /**
   * Get source that can handle a URL
   */
  getSourceForUrl(url: string): SourceIntegration | null {
    for (const source of this.sources.values()) {
      if (source.canHandleUrl(url)) {
        logger.debug(`Found source for URL '${url}': ${source.id}`);
        return source;
      }
    }
    
    logger.debug(`No source found for URL: ${url}`);
    return null;
  }
  
  /**
   * Get source by ID
   */
  getSourceById(sourceId: string): SourceIntegration | null {
    const source = this.sources.get(sourceId);
    return source || null;
  }
  
  /**
   * Extract paper ID from URL using appropriate source
   */
  extractPaperId(url: string): { sourceId: string, paperId: string } | null {
    for (const source of this.sources.values()) {
      if (source.canHandleUrl(url)) {
        const paperId = source.extractPaperId(url);
        if (paperId) {
          logger.debug(`Extracted paper ID '${paperId}' from URL using ${source.id}`);
          return { sourceId: source.id, paperId };
        }
      }
    }
    
    logger.debug(`Could not extract paper ID from URL: ${url}`);
    return null;
  }
  
  /**
   * Format a paper identifier using the appropriate source
   */
  formatPaperId(sourceId: string, paperId: string): string {
    const source = this.sources.get(sourceId);
    
    if (source) {
      return source.formatPaperId(paperId);
    }
    
    // Fallback if source not found
    logger.warning(`Source '${sourceId}' not found, using default format for paper ID`);
    return `${sourceId}.${paperId}`;
  }
  
  /**
   * Format an object ID using the appropriate source
   */
  formatObjectId(type: string, sourceId: string, paperId: string): string {
    const source = this.sources.get(sourceId);
    
    if (source) {
      return source.formatObjectId(type, paperId);
    }
    
    // Fallback if source not found
    logger.warning(`Source '${sourceId}' not found, using default format for object ID`);
    return `${type}:${sourceId}.${paperId}`;
  }
  
  /**
   * Get all content script match patterns
   */
  getAllContentScriptMatches(): string[] {
    const patterns: string[] = [];
    
    for (const source of this.sources.values()) {
      patterns.push(...source.contentScriptMatches);
    }
    
    return patterns;
  }
}



---
File: extension/source-integration/types.ts
---
// extension/source-integration/types.ts
// Updated SourceIntegration interface with identifier formatting methods

import type { Json } from 'gh-store-client';
import type { PaperMetadata } from '../papers/types';

/**
 * Source integration interface
 * Implementations should be importable by both background and content scripts
 */
export interface SourceIntegration {
  // Unique identifier
  readonly id: string;
  
  // Human-readable name
  readonly name: string;
  
  // URL patterns for matching papers from this source (as RegExp patterns)
  readonly urlPatterns: RegExp[];
  
  // Domain match patterns for content script registration
  readonly contentScriptMatches: string[];
  
  // Check if URL is from this source
  canHandleUrl(url: string): boolean;
  
  // Extract paper ID from URL
  extractPaperId(url: string): string | null;
  
  // Extract metadata from page or API
  extractMetadata(document: Document, paperId: string): Promise<PaperMetadata | null>;
  
  // Format a paper identifier (sourceId + paperId) for this source
  formatPaperId(paperId: string): string;
  
  // Parse a paper identifier specific to this source
  parsePaperId(identifier: string): string | null;
  
  // Format a storage object ID for this source
  formatObjectId(type: string, paperId: string): string;
}

/**
 * Manager interface for source integrations
 */
export interface SourceManager {
  // Register a source integration
  registerSource(source: SourceIntegration): void;
  
  // Get all registered sources
  getAllSources(): SourceIntegration[];
  
  // Get source for a given URL
  getSourceForUrl(url: string): SourceIntegration | null;
  
  // Extract paper ID from URL using appropriate source
  extractPaperId(url: string): { sourceId: string, paperId: string } | null;
  
  // Format a paper identifier using the appropriate source
  formatPaperId(sourceId: string, paperId: string): string;
  
  // Format an object ID using the appropriate source
  formatObjectId(type: string, sourceId: string, paperId: string): string;
}

// Other existing types...
// Message types for communication between background and content scripts

// Content script ready notification
export interface ContentScriptReadyMessage {
  type: 'contentScriptReady';
  url: string;
}

// Paper metadata message
export interface PaperMetadataMessage {
  type: 'paperMetadata';
  metadata: PaperMetadata;
}

// Start session message (new)
export interface StartSessionMessage {
  type: 'startSession';
  sourceId: string;
  paperId: string;
}

// Session heartbeat message (new)
export interface SessionHeartbeatMessage {
  type: 'sessionHeartbeat';
  sourceId: string;
  paperId: string;
  timestamp: number;
}

// End session message (new)
export interface EndSessionMessage {
  type: 'endSession';
  sourceId: string;
  paperId: string;
  reason?: string;
}

// Show annotation popup request
export interface ShowAnnotationPopupMessage {
  type: 'showAnnotationPopup';
  sourceId: string;
  paperId: string;
  position: { x: number, y: number };
}

// Popup action message
export interface PopupActionMessage {
  type: 'popupAction';
  action: string;
  sourceId: string;
  paperId: string;
  data: any;
}

// Show popup message
export interface ShowPopupMessage {
  type: 'showPopup';
  sourceId: string;
  paperId: string;
  html: string;
  handlers: Array<{
    selector: string;
    event: string;
    action: string;
  }>;
  position?: { x: number, y: number };
}

// Process page message
export interface ProcessPageMessage {
  type: 'processPage';
}

// Get current paper message
export interface GetCurrentPaperMessage {
  type: 'getCurrentPaper';
}

// Update rating message
export interface UpdateRatingMessage {
  type: 'updateRating';
  rating: string;
}

// Union type for all message types
export type Message = 
  | ContentScriptReadyMessage
  | PaperMetadataMessage
  | StartSessionMessage
  | SessionHeartbeatMessage
  | EndSessionMessage
  | ShowAnnotationPopupMessage
  | PopupActionMessage
  | ShowPopupMessage
  | ProcessPageMessage
  | GetCurrentPaperMessage
  | UpdateRatingMessage;



---
File: extension/tsconfig.json
---
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "lib": ["ES2020", "DOM"],
    "esModuleInterop": true,
    "strict": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "types": ["chrome", "@types/node"],
    "outDir": "dist",
    "baseUrl": "."
  },
  "include": [
    "**/*.ts",
    "background.js",
    "content.js",
    "popup.js",
    "options.js"
  ],
  "exclude": ["node_modules", "dist"]
}



---
File: extension/utils/logger.ts
---
// utils/logger.ts
// Logging utility wrapping loguru

/**
 * Logger class for consistent logging throughout the extension
 */
export class Logger {
  constructor(private module: string) {}
  
  /**
   * Log debug message
   */
  debug(message: string, data?: any): void {
    console.debug(`[${this.module}] ${message}`, data !== undefined ? data : '');
  }
  
  /**
   * Log info message
   */
  info(message: string, data?: any): void {
    console.info(`[${this.module}] ${message}`, data !== undefined ? data : '');
  }
  
  /**
   * Log warning message
   */
  warning(message: string, data?: any): void {
    console.warn(`[${this.module}] ${message}`, data !== undefined ? data : '');
  }
  
  /**
   * Log error message
   */
  error(message: string, data?: any): void {
    console.error(`[${this.module}] ${message}`, data !== undefined ? data : '');
  }
}

/**
 * Loguru mock for browser extension use
 */
class LoguruMock {
  /**
   * Get logger for a module
   */
  getLogger(module: string): Logger {
    return new Logger(module);
  }
}

// Export singleton instance
export const loguru = new LoguruMock();



---
File: extension/utils/metadata-extractor.ts
---
// extension/utils/metadata-extractor.ts
// Object-oriented metadata extraction system with customizable extraction methods

import { loguru } from './logger';

const logger = loguru.getLogger('metadata-extractor');

export interface ExtractedMetadata {
  title: string;
  authors: string;
  description: string;
  publishedDate: string;
  doi?: string;
  journalName?: string;
  tags?: string[];
  url?: string;
}

// Constants for standard source types
export const SOURCE_TYPES = {
  PDF: 'pdf',
  URL: 'url',
} as const;

export type SourceType = typeof SOURCE_TYPES[keyof typeof SOURCE_TYPES];

/**
 * Base class for metadata extraction with customizable extraction methods
 * Each method can be overridden to provide source-specific extraction
 */
export class MetadataExtractor {
  protected document: Document;
  protected url: string;
  
  /**
   * Create a new metadata extractor for a document
   */
  constructor(document: Document) {
    this.document = document;
    this.url = document.location.href;
    logger.debug('Initialized metadata extractor for:', this.url);
  }
  
  /**
   * Helper method to get content from meta tags
   */
  protected getMetaContent(selector: string): string {
    const element = this.document.querySelector(selector);
    return element ? element.getAttribute('content') || '' : '';
  }
  
  /**
   * Extract and return all metadata fields
   */
  public extract(): ExtractedMetadata {
    logger.debug('Extracting metadata from page:', this.url);
    
    const metadata: ExtractedMetadata = {
      title: this.extractTitle(),
      authors: this.extractAuthors(),
      description: this.extractDescription(),
      publishedDate: this.extractPublishedDate(),
      doi: this.extractDoi(),
      journalName: this.extractJournalName(),
      tags: this.extractTags(),
      url: this.url
    };
    
    logger.debug('Metadata extraction complete:', metadata);
    return metadata;
  }
  
  /**
   * Extract title from document
   * Considers multiple metadata standards with priority order
   */
  protected extractTitle(): string {
    // Title extraction - priority order
    return (
      // Dublin Core
      this.getMetaContent('meta[name="DC.Title"]') ||
      // Citation
      this.getMetaContent('meta[name="citation_title"]') ||
      // Open Graph
      this.getMetaContent('meta[property="og:title"]') ||
      // Standard meta
      this.getMetaContent('meta[name="title"]') ||
      // Fallback to document title
      this.document.title
    );
  }
  
  /**
   * Extract authors from document
   * Handles multiple author formats and sources
   */
  protected extractAuthors(): string {
    // Get all citation authors (some pages have multiple citation_author tags)
    const citationAuthors: string[] = [];
    this.document.querySelectorAll('meta[name="citation_author"]').forEach(el => {
      const content = el.getAttribute('content');
      if (content) citationAuthors.push(content);
    });
    
    // Get all DC creators
    const dcCreators: string[] = [];
    this.document.querySelectorAll('meta[name="DC.Creator.PersonalName"]').forEach(el => {
      const content = el.getAttribute('content');
      if (content) dcCreators.push(content);
    });
    
    // Individual author elements
    const dcCreator = this.getMetaContent('meta[name="DC.Creator.PersonalName"]');
    const citationAuthor = this.getMetaContent('meta[name="citation_author"]');
    const ogAuthor = this.getMetaContent('meta[property="og:article:author"]') ||
                    this.getMetaContent('meta[name="author"]');
    
    // Set authors with priority
    if (dcCreators.length > 0) {
      return dcCreators.join(', ');
    } else if (citationAuthors.length > 0) {
      return citationAuthors.join(', ');
    } else if (dcCreator) {
      return dcCreator;
    } else if (citationAuthor) {
      return citationAuthor;
    } else if (ogAuthor) {
      return ogAuthor;
    }
    
    return '';
  }
  
  /**
   * Extract description/abstract from document
   */
  protected extractDescription(): string {
    return (
      this.getMetaContent('meta[name="DC.Description"]') ||
      this.getMetaContent('meta[name="citation_abstract"]') ||
      this.getMetaContent('meta[property="og:description"]') ||
      this.getMetaContent('meta[name="description"]')
    );
  }
  
  /**
   * Extract publication date from document
   */
  protected extractPublishedDate(): string {
    return (
      this.getMetaContent('meta[name="DC.Date.issued"]') ||
      this.getMetaContent('meta[name="citation_date"]') ||
      this.getMetaContent('meta[property="article:published_time"]')
    );
  }
  
  /**
   * Extract DOI (Digital Object Identifier) from document
   */
  protected extractDoi(): string {
    return (
      this.getMetaContent('meta[name="DC.Identifier.DOI"]') ||
      this.getMetaContent('meta[name="citation_doi"]')
    );
  }
  
  /**
   * Extract journal name from document
   */
  protected extractJournalName(): string {
    return (
      this.getMetaContent('meta[name="DC.Source"]') ||
      this.getMetaContent('meta[name="citation_journal_title"]')
    );
  }
  
  /**
   * Extract keywords/tags from document
   */
  protected extractTags(): string[] {
    const keywords = this.getMetaContent('meta[name="keywords"]') ||
                    this.getMetaContent('meta[name="DC.Subject"]');
    
    if (keywords) {
      return keywords.split(',').map(tag => tag.trim());
    }
    
    return [];
  }
  
  /**
   * Determine if the current URL is a PDF
   */
  public isPdf(): boolean {
    return isPdfUrl(this.url);
  }
  
  /**
   * Get the source type (PDF or URL)
   */
  public getSourceType(): SourceType {
    return this.isPdf() ? SOURCE_TYPES.PDF : SOURCE_TYPES.URL;
  }
  
  /**
   * Generate a paper ID for the current URL
   */
  public generatePaperId(): string {
    return generatePaperIdFromUrl(this.url);
  }
}

/**
 * Create a common metadata extractor for a document
 * Factory function for creating the default extractor
 */
export function createMetadataExtractor(document: Document): MetadataExtractor {
  return new MetadataExtractor(document);
}

/**
 * Extract common metadata from a document
 * Convenience function for quick extraction
 */
export function extractCommonMetadata(document: Document): ExtractedMetadata {
  return createMetadataExtractor(document).extract();
}

/**
 * Generate a paper ID from a URL
 * Creates a consistent hash-based identifier
 */
export function generatePaperIdFromUrl(url: string): string {
  // Use a basic hash function to create an ID from the URL
  let hash = 0;
  for (let i = 0; i < url.length; i++) {
    const char = url.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // Convert to 32bit integer
  }
  
  // Create a positive hexadecimal string
  const positiveHash = Math.abs(hash).toString(16).toUpperCase();
  
  // Use the first 8 characters as the ID
  return positiveHash.substring(0, 8);
}

/**
 * Determine if a URL is a PDF
 */
export function isPdfUrl(url: string): boolean {
  return url.toLowerCase().endsWith('.pdf');
}



---
File: extension/utils/popup-manager.ts
---
// extension/utils/popup-manager.ts
// Popup management system integrated with source manager

import { SourceManager } from '../source-integration/types';
import { PaperManager } from '../papers/manager';
import { PaperMetadata } from '../papers/types';
import { loguru } from './logger';

const logger = loguru.getLogger('popup-manager');

/**
 * Popup handler information
 */
interface PopupHandler {
  selector: string;
  event: string;
  action: string;
}

/**
 * Popup message type
 */
interface ShowPopupMessage {
  type: 'showPopup';
  sourceId: string;
  paperId: string;
  html: string;
  handlers: PopupHandler[];
  position?: { x: number, y: number };
}

/**
 * Manages all popup-related functionality
 */
export class PopupManager {
  // Source manager and paper manager
  private sourceManagerProvider: () => SourceManager | null;
  private paperManagerProvider: () => PaperManager | null;
  
  /**
   * Create a new popup manager
   */
  constructor(
    sourceManagerProvider: () => SourceManager | null,
    paperManagerProvider: () => PaperManager | null
  ) {
    this.sourceManagerProvider = sourceManagerProvider;
    this.paperManagerProvider = paperManagerProvider;
    
    this.setupMessageListeners();
    logger.debug('Popup manager initialized');
  }
  
  /**
   * Set up message listeners for popup-related messages
   */
  private setupMessageListeners(): void {
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
      // Handle popup actions (ratings, notes, etc.)
      if (message.type === 'popupAction') {
        this.handlePopupAction(
          message.sourceId,
          message.paperId,
          message.action,
          message.data
        ).then(() => {
          sendResponse({ success: true });
        }).catch(error => {
          logger.error('Error handling popup action', error);
          sendResponse({ 
            success: false, 
            error: error instanceof Error ? error.message : 'Unknown error' 
          });
        });
        
        return true; // Will respond asynchronously
      }
      
      // Handle request to show annotation popup
      if (message.type === 'showAnnotationPopup' && sender.tab?.id) {
        this.handleShowAnnotationPopup(
          sender.tab.id,
          message.sourceId,
          message.paperId,
          message.position
        ).then(() => {
          sendResponse({ success: true });
        }).catch(error => {
          logger.error('Error showing popup', error);
          sendResponse({ 
            success: false, 
            error: error instanceof Error ? error.message : 'Unknown error'
          });
        });
        
        return true; // Will respond asynchronously
      }
      
      return false; // Not handled
    });
  }
  
  /**
   * Handle a request to show an annotation popup
   */
  private async handleShowAnnotationPopup(
    tabId: number,
    sourceId: string,
    paperId: string,
    position: { x: number, y: number }
  ): Promise<void> {
    logger.debug(`Showing annotation popup for ${sourceId}:${paperId}`);
    
    // Check if we have source and paper manager
    const sourceManager = this.sourceManagerProvider();
    const paperManager = this.paperManagerProvider();
    
    if (!sourceManager) {
      throw new Error('Source manager not initialized');
    }
    
    if (!paperManager) {
      throw new Error('Paper manager not initialized');
    }
    
    try {
      // Get paper data
      const paper = await paperManager.getPaper(sourceId, paperId);
      
      // Create popup HTML
      const html = this.createPopupHtml(paper || { 
        sourceId, 
        paperId,
        title: paperId,
        authors: '',
        abstract: '',
        url: '',
        timestamp: new Date().toISOString(),
        publishedDate: '',
        tags: [],
        rating: 'novote'
      });
      
      // Get handlers
      const handlers = this.getStandardPopupHandlers();
      
      // Send message to content script to show popup
      const message: ShowPopupMessage = {
        type: 'showPopup',
        sourceId,
        paperId,
        html,
        handlers,
        position
      };
      
      await chrome.tabs.sendMessage(tabId, message);
      
      logger.debug(`Sent popup to content script for ${sourceId}:${paperId}`);
    } catch (error) {
      logger.error(`Error showing popup for ${sourceId}:${paperId}`, error);
      throw error;
    }
  }
  
  /**
   * Handle popup actions (ratings, notes, etc.)
   */
  private async handlePopupAction(
    sourceId: string,
    paperId: string,
    action: string,
    data: any
  ): Promise<void> {
    const paperManager = this.paperManagerProvider();
    
    if (!paperManager) {
      throw new Error('Paper manager not initialized');
    }
    
    logger.debug(`Handling popup action: ${action}`, { sourceId, paperId });
    
    try {
      if (action === 'rate') {
        await paperManager.updateRating(sourceId, paperId, data.value);
        logger.info(`Updated rating for ${sourceId}:${paperId} to ${data.value}`);
      } 
      else if (action === 'saveNotes') {
        if (data.value) {
          await paperManager.logAnnotation(sourceId, paperId, 'notes', data.value);
          logger.info(`Saved notes for ${sourceId}:${paperId}`);
        }
      }
    } catch (error) {
      logger.error(`Error handling action ${action} for ${sourceId}:${paperId}`, error);
      throw error;
    }
  }
  
  /**
   * Create HTML for paper popup
   */
  private createPopupHtml(paper: PaperMetadata): string {
    return `
      <div class="paper-popup-header">${paper.title || paper.paperId}</div>
      <div class="paper-popup-meta">${paper.authors || ''}</div>
      
      <div class="paper-popup-buttons">
        <button class="vote-button" data-vote="thumbsup" id="btn-thumbsup" ${paper.rating === 'thumbsup' ? 'class="active"' : ''}>ðŸ‘ Interesting</button>
        <button class="vote-button" data-vote="thumbsdown" id="btn-thumbsdown" ${paper.rating === 'thumbsdown' ? 'class="active"' : ''}>ðŸ‘Ž Not Relevant</button>
      </div>
      
      <textarea placeholder="Add notes about this paper..." id="paper-notes"></textarea>
      
      <div class="paper-popup-actions">
        <button class="save-button" id="btn-save">Save</button>
      </div>
    `;
  }
  
  /**
   * Get standard popup event handlers
   */
  private getStandardPopupHandlers(): PopupHandler[] {
    return [
      { selector: '#btn-thumbsup', event: 'click', action: 'rate' },
      { selector: '#btn-thumbsdown', event: 'click', action: 'rate' },
      { selector: '#btn-save', event: 'click', action: 'saveNotes' }
    ];
  }
}



---
File: extension/utils/session-service.ts
---
// session-service.ts
// Simplified session tracking service for background script

import { loguru } from './logger';
import { PaperManager } from '../papers/manager';
import { ReadingSessionData, PaperMetadata } from '../papers/types';

const logger = loguru.getLogger('session-service');

/**
 * Session tracking service for paper reading sessions
 * 
 * Manages session state, heartbeats, and persistence
 * Designed for use in the background script (Service Worker)
 */
export class SessionService {
  private activeSession: {
    sourceId: string;
    paperId: string;
    startTime: Date;
    heartbeatCount: number;
    lastHeartbeatTime: Date;
  } | null = null;
  
  private timeoutId: number | null = null;
  private paperMetadata: Map<string, PaperMetadata> = new Map();
  
  // Configuration
  private readonly HEARTBEAT_TIMEOUT = 15000; // 15 seconds
  
  /**
   * Create a new session service
   */
  constructor(private paperManager: PaperManager | null) {
    logger.debug('Session service initialized');
  }
  
  /**
   * Start a new session for a paper
   */
  startSession(sourceId: string, paperId: string, metadata?: PaperMetadata): void {
    // End any existing session
    this.endSession();
    
    // Create new session
    this.activeSession = {
      sourceId,
      paperId,
      startTime: new Date(),
      heartbeatCount: 0,
      lastHeartbeatTime: new Date()
    };
    
    // Store metadata if provided
    if (metadata) {
      const key = `${sourceId}:${paperId}`;
      this.paperMetadata.set(key, metadata);
      logger.debug(`Stored metadata for ${key}`);
    }
    
    // Start timeout check
    this.scheduleTimeoutCheck();
    
    logger.info(`Started session for ${sourceId}:${paperId}`);
  }
  
  /**
   * Record a heartbeat for the current session
   */
  recordHeartbeat(): boolean {
    if (!this.activeSession) {
      return false;
    }
    
    this.activeSession.heartbeatCount++;
    this.activeSession.lastHeartbeatTime = new Date();
    
    // Reschedule timeout
    this.scheduleTimeoutCheck();
    
    if (this.activeSession.heartbeatCount % 12 === 0) { // Log every minute (12 x 5sec heartbeats)
      logger.debug(`Session received ${this.activeSession.heartbeatCount} heartbeats`);
    }
    
    return true;
  }
  
  /**
   * Schedule a check for heartbeat timeout
   */
  private scheduleTimeoutCheck(): void {
    // Clear existing timeout
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
    }
    
    // Set new timeout
    this.timeoutId = self.setTimeout(() => {
      this.checkTimeout();
    }, this.HEARTBEAT_TIMEOUT);
  }
  
  /**
   * Check if the session has timed out due to missing heartbeats
   */
  private checkTimeout(): void {
    if (!this.activeSession) return;
    
    const now = Date.now();
    const lastTime = this.activeSession.lastHeartbeatTime.getTime();
    
    if ((now - lastTime) > this.HEARTBEAT_TIMEOUT) {
      logger.info('Session timeout detected');
      this.endSession();
    } else {
      this.scheduleTimeoutCheck();
    }
  }
  
  /**
   * End the current session and get the data
   */
  endSession(): ReadingSessionData | null {
    if (!this.activeSession) return null;
    
    // Clear timeout
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
    
    const { sourceId, paperId, startTime, heartbeatCount } = this.activeSession;
    const endTime = new Date();
    
    // Calculate duration (5 seconds per heartbeat)
    const duration = heartbeatCount * 5;
    
    // Calculate total elapsed time
    const totalElapsed = endTime.getTime() - startTime.getTime();
    const totalElapsedSeconds = Math.round(totalElapsed / 1000);
    
    // Set idle seconds to the difference (for backward compatibility)
    const idleSeconds = Math.max(0, totalElapsedSeconds - duration);
    
    // Create session data
    const sessionData: ReadingSessionData = {
      session_id: `session_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`,
      source_id: sourceId,
      paper_id: paperId,
      start_time: startTime.toISOString(),
      end_time: endTime.toISOString(),
      heartbeat_count: heartbeatCount,
      duration_seconds: duration,
      // Legacy fields
      idle_seconds: idleSeconds,
      total_elapsed_seconds: totalElapsedSeconds
    };
    
    // Store session if it was meaningful and we have a paper manager
    if (this.paperManager && heartbeatCount > 0) {
      const metadata = this.getPaperMetadata(sourceId, paperId);
      
      this.paperManager.logReadingSession(sourceId, paperId, sessionData, metadata)
        .catch(err => logger.error('Failed to store session', err));
    }
    
    logger.info(`Ended session for ${sourceId}:${paperId}`, {
      duration,
      heartbeats: heartbeatCount
    });
    
    // Clear active session
    this.activeSession = null;
    
    return sessionData;
  }
  
  /**
   * Check if a session is currently active
   */
  hasActiveSession(): boolean {
    return this.activeSession !== null;
  }
  
  /**
   * Get information about the current session
   */
  getCurrentSession(): { sourceId: string, paperId: string } | null {
    if (!this.activeSession) return null;
    
    return {
      sourceId: this.activeSession.sourceId,
      paperId: this.activeSession.paperId
    };
  }
  
  /**
   * Get paper metadata for the current or specified session
   */
  getPaperMetadata(sourceId?: string, paperId?: string): PaperMetadata | undefined {
    if (!sourceId || !paperId) {
      if (!this.activeSession) return undefined;
      sourceId = this.activeSession.sourceId;
      paperId = this.activeSession.paperId;
    }
    
    return this.paperMetadata.get(`${sourceId}:${paperId}`);
  }
  
  /**
   * Store paper metadata
   */
  storePaperMetadata(metadata: PaperMetadata): void {
    const key = `${metadata.sourceId}:${metadata.paperId}`;
    this.paperMetadata.set(key, metadata);
  }
  
  /**
   * Get time since last heartbeat in milliseconds
   */
  getTimeSinceLastHeartbeat(): number | null {
    if (!this.activeSession) {
      return null;
    }
    
    return Date.now() - this.activeSession.lastHeartbeatTime.getTime();
  }
  
  /**
   * Get session statistics for debugging
   */
  getSessionStats(): any {
    if (!this.activeSession) {
      return { active: false };
    }
    
    return {
      active: true,
      sourceId: this.activeSession.sourceId,
      paperId: this.activeSession.paperId,
      startTime: this.activeSession.startTime.toISOString(),
      heartbeatCount: this.activeSession.heartbeatCount,
      lastHeartbeatTime: this.activeSession.lastHeartbeatTime.toISOString(),
      elapsedTime: Math.round((Date.now() - this.activeSession.startTime.getTime()) / 1000)
    };
  }
}



---
File: frontend/index.html
---
<!DOCTYPE html>
<!-- index.html - Root of GitHub Pages site -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DigThatData Papers Feed</title>
  
  <!-- Tabulator CSS and JS -->
  <link href="https://unpkg.com/tabulator-tables@6.3.0/dist/css/tabulator.min.css" rel="stylesheet">
  <script src="https://unpkg.com/tabulator-tables@6.3.0/dist/js/tabulator.min.js"></script>
  
  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <link rel="stylesheet" href="papersfeed.css">
</head>
<body>
  <div class="header">
    <div class="header-title">
        <h1>ArXiv Paper Feed</h1>
        <p class="header-desc">Papers recently visited by <a href="https://bsky.app/profile/digthatdata.bsky.social">@DigThatData</a></p>
    </div>

    <div class="controls">
      <div class="search-box">
        <input type="text" id="search-input" placeholder="Search papers by title, author, or content...">
      </div>
      <button class="filter-button" id="sidebar-toggle">
        <i class="fas fa-filter"></i> Filters
      </button>
    </div>
  </div>
  
  <div class="dashboard-container">
    <div class="main-content">
      <div id="papers-table">
        <div class="loading">Loading papers data...</div>
      </div>
    </div>
    
    <!-- Filter Sidebar -->
    <div class="sidebar" id="sidebar">
      <h3>Filters</h3>
      
      <div class="filter-section">
        <h4>Publication Date</h4>
        <div id="date-filter-controls">
          <div>
            <label for="date-filter-from">From:</label>
            <input type="date" id="date-filter-from">
          </div>
          <div style="margin-top: 10px;">
            <label for="date-filter-to">To:</label>
            <input type="date" id="date-filter-to">
          </div>
          <div style="margin-top: 15px;">
            <button id="apply-date-filter" class="filter-button">Apply</button>
            <button id="clear-date-filter" class="filter-button">Clear</button>
          </div>
        </div>
      </div>
      
      <div class="filter-section">
        <h4>Reading Status</h4>
        <div>
          <label>
            <input type="checkbox" id="filter-read" checked> Show Read Papers
          </label>
        </div>
        <div>
          <label>
            <input type="checkbox" id="filter-unread" checked> Show Unread Papers
          </label>
        </div>
      </div>
      
      <div class="filter-section">
        <h4>Reading Time</h4>
        <div>
          <label for="min-reading-time">Minimum (minutes):</label>
          <input type="number" id="min-reading-time" min="0" step="1">
        </div>
        <div style="margin-top: 10px;">
          <button id="apply-reading-filter" class="filter-button">Apply</button>
          <button id="clear-reading-filter" class="filter-button">Clear</button>
        </div>
      </div>
      
      <div class="filter-section">
        <h4>Interaction Days</h4>
        <div>
          <label for="min-interaction-days">Minimum days:</label>
          <input type="number" id="min-interaction-days" min="0" step="1">
        </div>
        <div style="margin-top: 10px;">
          <button id="apply-days-filter" class="filter-button">Apply</button>
          <button id="clear-days-filter" class="filter-button">Clear</button>
        </div>
      </div>
      
      <div class="filter-section">
        <h4>Reset All Filters</h4>
        <button id="reset-all-filters" class="filter-button">Reset All</button>
      </div>
    </div>
    
    <!-- Details Sidebar (new) -->
    <div class="sidebar" id="details-sidebar">
      <div id="details-content"></div>
    </div>
  </div>
  
  <button id="filter-toggle-btn" title="Toggle Filters">
    <i class="fas fa-filter"></i>
  </button>

  <script src="papersfeed.js"></script>
</body>
</html>



---
File: frontend/papersfeed.css
---
/* frontend/papersfeed.css */
body {
  margin: 0;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  background-color: #f5f7fa;
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}

.header {
  padding: 20px 20px 15px 20px;
  background-color: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  z-index: 10;
}

h1 {
  margin: 0 0 10px 0;
  color: #333;
}

.controls {
  display: flex;
  gap: 10px;
  margin-bottom: 10px;
}

.search-box {
  flex-grow: 1;
}

#search-input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 16px;
}

.filter-button {
  padding: 8px 15px;
  background-color: #f0f0f0;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 5px;
}

.filter-button:hover {
  background-color: #e8e8e8;
}

.dashboard-container {
  display: flex;
  flex: 1;
  overflow: hidden;
  position: relative;
}

.main-content {
  flex: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

#papers-table {
  flex: 1;
  width: 100%;
}

/* Shared sidebar styles */
.sidebar {
  background-color: white;
  box-shadow: -2px 0 5px rgba(0,0,0,0.1);
  overflow-y: auto;
  transition: all 0.3s ease;
  position: absolute;
  right: 0;
  top: 0;
  bottom: 0;
  width: 0;
  z-index: 100;
}

.sidebar.active {
  width: 400px;
  padding: 20px;
}

/* Filter sidebar specific */
#sidebar h3 {
  margin-top: 0;
  margin-bottom: 15px;
}

.filter-section {
  margin-bottom: 20px;
}

.filter-section h4 {
  margin-top: 0;
  margin-bottom: 10px;
  border-bottom: 1px solid #eee;
  padding-bottom: 5px;
}

/* Details sidebar specific */
#details-sidebar {
  z-index: 101; /* Higher than filter sidebar */
}

.details-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 20px;
}

.details-header h2 {
  margin: 0;
  flex: 1;
  line-height: 1.3;
}

.close-button {
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
  color: #666;
  padding: 0;
  margin-left: 15px;
}

.close-button:hover {
  color: #333;
}

.detail-section {
  margin-bottom: 25px;
  background-color: #f9f9f9;
  border-radius: 6px;
  padding: 15px;
}

.detail-section h3 {
  margin-top: 0;
  margin-bottom: 15px;
  color: #333;
  font-size: 1.1em;
  border-bottom: 1px solid #eee;
  padding-bottom: 8px;
}

.detail-table {
  width: 100%;
  border-collapse: collapse;
}

.detail-table th {
  text-align: left;
  padding: 8px;
  color: #666;
  font-weight: 600;
  width: 30%;
  vertical-align: top;
}

.detail-table td {
  padding: 8px;
  vertical-align: top;
}

.abstract-box {
  max-height: 300px;
  overflow-y: auto;
  padding: 15px;
  background-color: white;
  border-radius: 4px;
  line-height: 1.5;
  white-space: pre-line;
}

.tag {
  display: inline-block;
  background-color: #e8f0fe;
  padding: 3px 8px;
  margin: 2px;
  border-radius: 12px;
  font-size: 12px;
}

.loading {
  text-align: center;
  padding: 40px;
  font-size: 18px;
  color: #666;
}

.sessions-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 10px;
}

.sessions-table th {
  background-color: #f2f2f2;
  padding: 8px;
  text-align: left;
}

.sessions-table td {
  padding: 8px;
  border-bottom: 1px solid #eee;
}

/* Toggle button for the sidebar */
#filter-toggle-btn {
  position: fixed;
  right: 20px;
  bottom: 20px;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background-color: #1a73e8;
  color: white;
  border: none;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  transition: background-color 0.3s;
  z-index: 102; /* Above both sidebars */
}

#filter-toggle-btn:hover {
  background-color: #1558b7;
}

/* Tabulator customizations */
.tabulator {
  border: none;
  background-color: transparent;
}

.tabulator-row {
  border-bottom: 1px solid #f0f0f0;
  cursor: pointer;
}

.tabulator-row:hover {
  background-color: #f2f8fd !important;
}

.tabulator-row.tabulator-row-even {
  background-color: #fafafa;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .sidebar.active {
    width: 85%;
  }
  
  .detail-grid {
    grid-template-columns: 1fr;
  }
}



---
File: frontend/papersfeed.js
---
// frontend/papersfeed.js
// Global variables
let table;
let allData = [];
let currentDetailsPaper = null;

// Format date to YYYY-MM-DD format
function formatDate(dateString) {
  if (!dateString) return '';
  const date = new Date(dateString);
  return date.toISOString().split('T')[0]; // YYYY-MM-DD format
}

// Format reading time from seconds to minutes
function formatReadingTime(seconds) {
  if (!seconds || seconds === 0) return 'Not read';
  const minutes = Math.round(seconds / 60);
  return minutes + (minutes === 1 ? ' minute' : ' minutes');
}

// Custom cell formatter for tags
function formatTags(cell) {
  const tags = cell.getValue();
  if (!tags || !Array.isArray(tags) || tags.length === 0) {
    return '';
  }
  
  return tags.map(tag => 
    `<span class="tag">${tag}</span>`
  ).join(' ');
}

// Format interactions for display
function formatInteractions(interactions) {
  if (!interactions || interactions.length === 0) {
    return '<p>No reading sessions recorded</p>';
  }
  
  return `
    <table class="sessions-table">
      <thead>
        <tr>
          <th>Date</th>
          <th>Duration</th>
          <th>Session ID</th>
        </tr>
      </thead>
      <tbody>
        ${interactions.map(interaction => {
          const date = new Date(interaction.timestamp);
          return `
            <tr>
              <td>${date.toLocaleString()}</td>
              <td>${interaction.data.duration_seconds} seconds</td>
              <td>${interaction.data.session_id}</td>
            </tr>
          `;
        }).join('')}
      </tbody>
    </table>
  `;
}

// Display paper details in the details sidebar
function displayPaperDetails(paperId) {
  console.log("Displaying details for paper ID:", paperId);
  
  // Find the paper data
  const paper = allData.find(p => p.paperKey === paperId);
  if (!paper) {
    console.error('Paper not found:', paperId);
    return;
  }
  
  // Update the current paper
  currentDetailsPaper = paper;
  
  // Get the details sidebar and content
  const detailsSidebar = document.getElementById('details-sidebar');
  const detailsContent = document.getElementById('details-content');
  
  // Update the content
  detailsContent.innerHTML = `
    <div class="details-header">
      <h2>${paper.title}</h2>
      <button id="close-details" class="close-button">
        <i class="fas fa-times"></i>
      </button>
    </div>
    
    <div class="detail-section">
      <h3>Paper Details</h3>
      <table class="detail-table">
        <tr>
          <th>ID:</th>
          <td>${paper.id}</td>
        </tr>
        <tr>
          <th>Authors:</th>
          <td>${paper.authors}</td>
        </tr>
        <tr>
          <th>Publication Date:</th>
          <td>${paper.published}</td>
        </tr>
        <tr>
          <th>Last Read:</th>
          <td>${paper.lastRead}</td>
        </tr>
        <tr>
          <th>Reading Time:</th>
          <td>${paper.readingTime}</td>
        </tr>
        <tr>
          <th>Interaction Days:</th>
          <td>${paper.interactionDays === 1 ? '1 day' : paper.interactionDays + ' days'}</td>
        </tr>
        <tr>
          <th>arXiv Tags:</th>
          <td>${formatTags({ getValue: () => paper.tags })}</td>
        </tr>
        <tr>
          <th>URL:</th>
          <td><a href="${paper.url}" target="_blank">${paper.url}</a></td>
        </tr>
      </table>
    </div>
    
    <div class="detail-section">
      <h3>Abstract</h3>
      <div class="abstract-box">
        ${paper.abstract}
      </div>
    </div>
    
    <div class="detail-section">
      <h3>Reading Sessions</h3>
      ${formatInteractions(paper.rawInteractionData)}
    </div>
  `;
  
  // Show the sidebar
  detailsSidebar.classList.add('active');
  
  // Set up close button
  const closeButton = document.getElementById('close-details');
  if (closeButton) {
    closeButton.addEventListener('click', function() {
      detailsSidebar.classList.remove('active');
    });
  }
}

function removePrefix(string, prefix, sep = ':') {
  if (string.startsWith(prefix + sep)) {
    return string.slice(prefix.length + sep.length);
  }
  return null; // Return null to indicate no match
}

function extractObjectId(string, prefix) {
  // Case 1: Format is "prefix:id"
  let result = removePrefix(string, prefix, ':');
  if (result !== null) return result;
  
  // Case 2: Format is "prefix.id"
  result = removePrefix(string, prefix, '.');
  if (result !== null) return result;
  
  // Case 3: Format is "prefix:prefix:id"
  result = removePrefix(string, prefix + ':' + prefix, ':');
  if (result !== null) return result;
  
  // Case 3 alternate: Format is "prefix.prefix.id"
  result = removePrefix(string, prefix + '.' + prefix, '.');
  if (result !== null) return result;
  
  // Case 4: If none of the above, return the original string
  return string;
}

function extractDomain(url) {
  try {
    const urlObj = new URL(url);
    return urlObj.hostname;
  } catch (error) {
    // Handle invalid URLs
    console.error("Invalid URL:", error);
    return null;
  }
}

// Process complex data structure
function processComplexData(data) {
  const result = [];
  const objects = data.objects;
  const paperKeys = Object.keys(objects).filter(key => key.startsWith("paper:"));
  
  for (const paperKey of paperKeys) {
    //const paperId = paperKey.split(":", 1)[1];
    const paperId = extractObjectId(paperKey, "paper");
    const paperRaw = objects[paperKey];
    const paperData = paperRaw.data;
    const paperMeta = paperRaw.meta;
    const interactionKey = `interactions:${paperId}`;
    const interactionData = objects[interactionKey] ? objects[interactionKey].data : null;
    
    // Calculate reading time
    let totalReadingTime = 0;
    let lastReadDate = null;
    
    // Calculate unique days with interactions
    let uniqueInteractionDays = 0;
    
    if (interactionData && interactionData.interactions) {
      const uniqueDays = new Set();
      
      for (const interaction of interactionData.interactions) {
        if (interaction.type === "reading_session") {
          totalReadingTime += interaction.data.duration_seconds || 0;
          
          // Find the most recent reading session
          const sessionDate = new Date(interaction.timestamp);
          if (!lastReadDate || sessionDate > lastReadDate) {
            lastReadDate = sessionDate;
          }
          
          // Track unique days
          if (interaction.timestamp) {
            const date = new Date(interaction.timestamp);
            const dateString = date.toISOString().split('T')[0]; // YYYY-MM-DD
            uniqueDays.add(dateString);
          }
        }
      }
      
      uniqueInteractionDays = uniqueDays.size;
    }

    const source = paperData.sourceId === 'arxiv' || paperData.sourceType === 'arxiv' ? 
               'arxiv' : (paperData.url ? extractDomain(paperData.url) : null) ||
                 paperData.sourceId || paperData.sourceType;
    
    // Create the row data
    result.push({
      paperKey: paperKey,
      id: paperId, //paperData.paper_id || paperData.arxivId,
      source: source,
      title: paperData.title,
      authors: paperData.authors,
      abstract: paperData.abstract,
      //published: paperData.publishedDate,  //formatDate(paperData.publishedDate) : '', //paperData.published_date || paperData.published || '',
      published: paperData.published_date ? formatDate(paperData.published_date) : '',
      firstRead: formatDate(paperMeta.created_at),
      lastRead: lastReadDate ? formatDate(lastReadDate) : formatDate(paperMeta.updated_at),
      readingTime: formatReadingTime(totalReadingTime),
      readingTimeSeconds: totalReadingTime,
      interactionDays: uniqueInteractionDays,
      tags: paperData.arxiv_tags || [],
      url: paperData.url,
      rawInteractionData: interactionData ? interactionData.interactions : [],
      hasBeenRead: lastReadDate !== null
    });
  }
  
  return result;
}

// Initialize the Tabulator table
function initTable(data) {
  table = new Tabulator("#papers-table", {
    data: data,
    layout: "fitColumns",
    responsiveLayout: "collapse",
    pagination: "local",
    paginationSize: 100,
    paginationSizeSelector: [10, 25, 50, 100, 500, 1000],
    movableColumns: true,
    groupBy: "lastRead",
    initialSort: [
      {column: "lastRead", dir: "desc"}
    ],
    columns: [
      {
        title: "ID", 
        field: "id", 
        widthGrow: 1
      },
      {
        title: "Source", 
        field: "source", 
        widthGrow: 1
      },
      {
        title: "Title", 
        field: "title", 
        widthGrow: 3,
        formatter: function(cell) {
          const value = cell.getValue();
          return value;
        }
      },
      {
        title: "Authors", 
        field: "authors", 
        widthGrow: 2
      },
      {
        title: "Published", 
        field: "published", 
        widthGrow: 1
      },
      {
        title: "First Read", 
        field: "firstRead", 
        widthGrow: 1
      },
      {
        title: "Last Read", 
        field: "lastRead", 
        widthGrow: 1
      },
      {
        title: "Reading Time", 
        field: "readingTimeSeconds", 
        widthGrow: 1,
        formatter: function(cell) {
          return cell.getRow().getData().readingTime;
        }
      },
      {
        title: "Days", 
        field: "interactionDays", 
        widthGrow: 1,
        formatter: function(cell) {
          const value = cell.getValue();
          if (value === 0) return "None";
          return value === 1 ? "1 day" : `${value} days`;
        }
      },
      {
        title: "Tags", 
        field: "tags", 
        widthGrow: 2,
        formatter: formatTags
      }
    ],
    rowFormatter: function(row) {
      // Add classes based on read status
      // if (row.getData().hasBeenRead) {
      //   row.getElement().classList.add("paper-read");
      // } else {
      //   row.getElement().classList.add("paper-unread");
      // }
      
      // Add paper ID as data attribute
      const rowElement = row.getElement();
      const paper_Id = row.getData().paperKey;
      //const paper_Id = row.getData("id");
      console.log("formatter detected paperId:", paper_Id);
      rowElement.setAttribute("data-paper-id", paper_Id);
    }
  });
  
  // Remove loading message
  document.querySelector(".loading").style.display = "none";
  
  // Set up global click handler for the table
  document.getElementById("papers-table").addEventListener("click", function(e) {
    // Find the closest row element
    const rowElement = e.target.closest(".tabulator-row");
    if (rowElement) {
      const paperId = rowElement.getAttribute("data-paper-id");
      console.log("detected click on row for paperId:", paperId);
      if (paperId) {
        displayPaperDetails(paperId);
      }
    }
  });
}

// Setup event listeners for filters and search
function setupEventListeners() {
  // Global search
  document.getElementById("search-input").addEventListener("input", function(e) {
    table.setFilter(function(data) {
      const searchTerm = e.target.value.toLowerCase();
      if (!searchTerm) return true;
      
      // Search in title, authors, abstract, and tags
      return (
        data.title.toLowerCase().includes(searchTerm) ||
        data.authors.toLowerCase().includes(searchTerm) ||
        data.abstract.toLowerCase().includes(searchTerm) ||
        (data.tags && data.tags.some(tag => tag.toLowerCase().includes(searchTerm)))
      );
    });
  });
  
  // Toggle filter sidebar
  document.getElementById("sidebar-toggle").addEventListener("click", function() {
    document.getElementById("sidebar").classList.toggle("active");
    
    // Close details sidebar if open (to avoid both being open at once)
    document.getElementById("details-sidebar").classList.remove("active");
  });
  
  // Floating filter button
  document.getElementById("filter-toggle-btn").addEventListener("click", function() {
    document.getElementById("sidebar").classList.toggle("active");
    
    // Close details sidebar if open (to avoid both being open at once)
    document.getElementById("details-sidebar").classList.remove("active");
  });
  
  // Toggle details with keyboard escape key
  document.addEventListener("keydown", function(e) {
    if (e.key === "Escape") {
      document.getElementById("details-sidebar").classList.remove("active");
      document.getElementById("sidebar").classList.remove("active");
    }
  });
  
  // Date filter
  document.getElementById("apply-date-filter").addEventListener("click", function() {
    const fromDate = document.getElementById("date-filter-from").value;
    const toDate = document.getElementById("date-filter-to").value;
    
    table.setFilter(function(data) {
      if (!fromDate && !toDate) return true;
      if (!data.published) return false;
      
      if (fromDate && toDate) {
        return data.published >= fromDate && data.published <= toDate;
      }
      
      if (fromDate) {
        return data.published >= fromDate;
      }
      
      if (toDate) {
        return data.published <= toDate;
      }
      
      return true;
    });
  });
  
  document.getElementById("clear-date-filter").addEventListener("click", function() {
    document.getElementById("date-filter-from").value = "";
    document.getElementById("date-filter-to").value = "";
    table.clearFilter();
  });
  
  // Read/Unread filters
  function updateReadFilter() {
    const showRead = document.getElementById("filter-read").checked;
    const showUnread = document.getElementById("filter-unread").checked;
    
    if (showRead && showUnread) {
      table.removeFilter("hasBeenRead");
      return;
    }
    
    if (showRead) {
      table.setFilter("hasBeenRead", "=", true);
      return;
    }
    
    if (showUnread) {
      table.setFilter("hasBeenRead", "=", false);
      return;
    }
    
    // If neither is checked, show nothing
    table.setFilter(function() { return false; });
  }
  
  document.getElementById("filter-read").addEventListener("change", updateReadFilter);
  document.getElementById("filter-unread").addEventListener("change", updateReadFilter);
  
  // Reading time filter
  document.getElementById("apply-reading-filter").addEventListener("click", function() {
    const minReading = document.getElementById("min-reading-time").value;
    
    if (!minReading) {
      table.removeFilter("readingTimeSeconds");
      return;
    }
    
    const minSeconds = parseInt(minReading) * 60;
    table.setFilter("readingTimeSeconds", ">=", minSeconds);
  });
  
  document.getElementById("clear-reading-filter").addEventListener("click", function() {
    document.getElementById("min-reading-time").value = "";
    table.removeFilter("readingTimeSeconds");
  });
  
  // Interaction days filter
  document.getElementById("apply-days-filter").addEventListener("click", function() {
    const minDays = document.getElementById("min-interaction-days").value;
    
    if (!minDays) {
      table.removeFilter("interactionDays");
      return;
    }
    
    table.setFilter("interactionDays", ">=", parseInt(minDays));
  });
  
  document.getElementById("clear-days-filter").addEventListener("click", function() {
    document.getElementById("min-interaction-days").value = "";
    table.removeFilter("interactionDays");
  });
  
  // Reset all filters
  document.getElementById("reset-all-filters").addEventListener("click", function() {
    // Clear all input fields
    document.getElementById("search-input").value = "";
    document.getElementById("date-filter-from").value = "";
    document.getElementById("date-filter-to").value = "";
    document.getElementById("min-reading-time").value = "";
    document.getElementById("min-interaction-days").value = "";
    
    // Reset checkboxes
    document.getElementById("filter-read").checked = true;
    document.getElementById("filter-unread").checked = true;
    
    // Clear all table filters
    table.clearFilter();
  });
}

// Load and initialize
document.addEventListener("DOMContentLoaded", function() {
  // Fetch data file
  fetch("gh-store-snapshot.json")
    .then(response => {
      if (!response.ok) {
        throw new Error("Failed to load data.json");
      }
      return response.json();
    })
    .then(data => {
      allData = processComplexData(data);
      initTable(allData);
      setupEventListeners();
    })
    .catch(error => {
      document.querySelector(".loading").innerHTML = 
        `Error loading data: ${error.message}. Make sure data.json exists in the same directory as this HTML file.`;
    });
});



---
File: pyproject.toml
---
[project]
name = "papers-feed"
version = "0.1.0"
description = ""
requires-python = ">=3.11"
# dependencies = [
#    "papers_feed"
# ]
readme = "README.md"
license = {file = "LICENSE"}


[tool.summary]
max_file_size_kb = 500  # Skip files larger than 1MB

# File patterns to exclude
exclude_patterns = [
    '.git',
    '.gitignore',
    '.pytest_cache',
    '__pycache__',
    'SUMMARY',
    '.coverage',
    '.env',
    '.venv',
    '.idea',
    '.vscode',
    'README.md',
    'README_LLM.md',
    'package-lock.json',
    'REGISTRY.md',
    'research.yaml',
    'registry.yaml',
    'bibliography',
    '.bibtex',
    'metadata.json',
    'events.log',
    'papers.yaml'
]

# File extensions to include
include_extensions = [
    '.py',
    '.md',
    '.txt',
    '.yml',
    '.yaml',
    '.toml',
    '.json',
    '.html',
    '.css',
    '.js',
    '.ts',
    '.tsx',
    '.j2'
]

# Directories to exclude
exclude_directories = [
    '.git',
    '__pycache__',
    '.pytest_cache',
    '.venv',
    '.idea',
    '.vscode',
    'data',
    'extension/dist/'
]



---
File: requirements.txt
---



---
File: scripts/hydrate_metadata.py
---
# this could probably be rolled into enrichment processing
#!/usr/bin/env python
# fetch_arxiv_metadata.py
"""
Fetches metadata for arXiv papers identified by issue labels and stores it using gh-store.
"""

import json
import sys
import os
import re
from typing import Dict, List, Optional, Any
import fire
from loguru import logger
import arxiv
import requests

from gh_store.core.store import GitHubStore
from gh_store.tools.canonicalize import CanonicalStore
#from gh_store.tools.canonicalize import CanonicalStore as GitHubStore
from gh_store.core.constants import LabelNames
from gh_store.core.types import get_object_id_from_labels, StoredObject
from gh_store.core.exceptions import DuplicateUIDError, ConcurrentUpdateError

def is_metadata_satisfied(data: dict) -> bool:
    return data and data.get('title') and not (data.get('id') in data.get('title'))

def is_valid_arxiv_id(arxiv_id: str) -> bool:
    """Validate arXiv ID format."""
    return bool(re.match(r'\d{4}\.\d{4,5}(v\d+)?|\w+\/\d{7}(v\d+)?', arxiv_id))

def extract_arxiv_id_from_object_id(object_id: str) -> str:
    """Extract the arXiv ID from a paper ID with various prefixing schemes."""
    prefix = 'arxiv'
    
    # Case 1: Format is "prefix:id"
    if object_id.startswith(f"{prefix}:"):
        return object_id[len(prefix)+1:]
    
    # Case 2: Format is "prefix.id"
    if object_id.startswith(f"{prefix}."):
        return object_id[len(prefix)+1:]
    
    # Case 3: Format is "prefix:prefix:id"
    if object_id.startswith(f"{prefix}:{prefix}:"):
        return object_id[len(prefix)*2+2:]
    
    # Case 4: Format is "prefix.prefix.id"
    if object_id.startswith(f"{prefix}.{prefix}."):
        return object_id[len(prefix)*2+2:]
    
    # Case 5: If none of the above, return the original ID
    return object_id

def fetch_arxiv_metadata(arxiv_id: str) -> Dict[str, Any]:
    """Fetch metadata from arXiv API for a given ID using the arxiv client."""
    logger.info(f"Fetching metadata for arXiv ID: {arxiv_id}")
    
    client = arxiv.Client()
    search = arxiv.Search(id_list=[arxiv_id])
    paper = next(client.results(search))
    if not paper:
        raise ValueError(f"No paper found with arXiv ID: {arxiv_id}")
    
    metadata = {
        #'id': paper.entry_id,
        'title': paper.title,
        'authors': [author.name for author in paper.authors],
        'publishedDate': paper.published.isoformat() if paper.published else None,
        #'updated': paper.updated.isoformat() if paper.updated else None,
        'doi': paper.doi,
        'tags': paper.categories,
        'abstract': paper.summary,
        #'links': [{'href': link.href, 'type': link.type} for link in paper.links],
        #'comment': paper.comment,
        #'journal_ref': paper.journal_ref,
        #'primary_category': paper.primary_category,
        #'pdf_url': paper.pdf_url,
    }
    
    logger.info(f"Successfully fetched metadata for arXiv ID: {arxiv_id}")
    logger.info(metadata)
    return metadata
    

def hydrate_issue_metadata(issue: int, token:str, repo:str):
    #store = GitHubStore(token=token, repo=repo, config_path=None)
    store = CanonicalStore(token=token, repo=repo, config_path=None)
    
    obj = store.issue_handler.get_object_by_number(issue)
    object_id = obj.meta.object_id
    #object_id = get_object_id_from_labels(issue)
    if not object_id.startswith("paper:"):
        logger.info("Not a paper object, exiting.")
        sys.exit(0)
    if 'url' in object_id:
        logger.info("Metadata hydration is currently only supported for the arxiv source type.")
        store.process_updates(issue) # ...why is this a separate second step? sheesh, I reaaly did rube goldberg the shit out of this thing
        return
        
    
    paper_id = object_id[len('paper:'):]
    if paper_id.startswith('arxiv'):
        arxiv_id = extract_arxiv_id_from_object_id(paper_id)
    elif is_valid_arxiv_id(paper_id):
        arxiv_id = paper_id
    else:
        raise TypeError(f"Unable to identify arxiv_id from object_id: {object_id}")

    updates = {}
    arxiv_meta = fetch_arxiv_metadata(arxiv_id)
    for k, v_new in arxiv_meta.items():
        #v_old = getattr(obj.data, k)
        v_old = obj.data.get(k)
        if not v_old:
            updates[k] = v_new

    metadata_satisfied = False
    if updates:
        # Issue is open because we are processing it right now, which acts as an implicit lock on updates.
        # so we close it before pushing the new update
        #store.repo.get_issue(issue).edit(state='closed') # ...this is awkward af. in fact, I think I should just eliminate that whole ConcurrentUpdateError
        # finally: what we came here for
        store.update(object_id=object_id, changes=updates)
        store.process_updates(issue) # ...why is this a separate second step? sheesh, I reaaly did rube goldberg the shit out of this thing
        metadata_satisfied = True
    else:
        metadata_satisfied = is_metadata_satisfied(obj.data)

    if metadata_satisfied:
        store.repo.get_issue(issue).remove_from_labels("TODO:hydrate-metadata")    

# TODO: upstream this to gh-store utilities
def get_open_issues(token:str, repo:str, extra_labels: list|None = None):
    store = GitHubStore(token=token, repo=repo, config_path=None)
    #store = CanonicalStore(token=token, repo=repo, config_path=None)
    
    query_labels = [LabelNames.GH_STORE, LabelNames.STORED_OBJECT]
    if extra_labels: # 
        query_labels += extra_labels
    return store.repo.get_issues(
            labels=query_labels,
            state="open"
        )

def hydrate_all_open_issues(token:str, repo:str):
    store = CanonicalStore(token=token, repo=repo, config_path=None)
    for issue in get_open_issues(token=token, repo=repo, extra_labels=["TODO:hydrate-metadata"]):
        try:
            hydrate_issue_metadata(issue=issue.number, token=token, repo=repo)
        except TypeError:
            logger.info("unsupported source for issue %s", issue.number)
        except DuplicateUIDError:
            #logger.info("Issue %s has dupes, skipping for now. Run deduplification." % issue.number)
            logger.info("Issue %s has dupes. Running deduplification." % issue.number)
            #object_id = StoredObject.from_issue(issue).object_id
            object_id = get_object_id_from_labels(issue)
            dedupe_status = store.deduplicate_object(object_id)
            hydrate_issue_metadata(issue=dedupe_status.get('canonical_issue'), token=token, repo=repo)
        except ConcurrentUpdateError:
            logger.info("Issue %s has too many unprocessed concurrent updates. Either adjust this threshold, or reconcile the updates manually.", issue.number)

# class Main:
#     def hydrate_issue_metadata(self, issue: int, token:str, repo:str):
#         hydrate_issue_metadata(issue=issue, token=token, repo=repo)

#     def hydrate_all_open_issues(self, token:str, repo:str):
#         hydrate_all_open_issues(token=token, repo=repo)


if __name__ == "__main__":
    #fire.Fire(Main)
    fire.Fire(
        { "hydrate_issue_metadata":hydrate_issue_metadata, "hydrate_all_open_issues":hydrate_all_open_issues }
    )



---
File: scripts/process_pdf.py
---
# .github/scripts/process_pdf.py

import os
from pathlib import Path
from typing import Literal

import fire
import requests
from loguru import logger
from lxml import etree
from llamero.utils import commit_and_push

OutputFormat = Literal['markdown', 'tei']

def remove_extra_whitespace(text: str)->str:
    while '\n\n\n' in text:
        text = text.replace('\n\n\n', '\n\n')
    return text

def remove_gibberish(
    text: str,
    cutoff=2000
)->str:
    good_lines = []
    for line in text.split('\n'):
        _line = line[:]
        if _line.startswith("$"):
            _line = _line[1:-1]
        n_tok = len(_line)
        n_space = _line.count(" ")
        # I think this might remove some formulas if we use cutoff=0
        token_sparsity=1
        if n_tok:
            token_sparsity = n_space/n_tok
        
        _line = line[:]
        _line = _line.replace(" ","")

        skip=False
        if (abs(token_sparsity - .5) < .01) and (len(line) > cutoff):
            skip=True
        if "texitsha1_base64" in _line:
            skip=True
        if "texit>" in _line:
            skip=True
        if skip:
            logger.info(f"removing gibberish")
            logger.info(line)
            continue
        good_lines.append(line)
    return '\n'.join(good_lines)

def sanitize_markdown(text: str)->str:
    text=remove_extra_whitespace(text)
    text=remove_gibberish(text)
    return text

def get_feature_path(base_path: Path, feature_type: str, paper_id: str, ext: str) -> Path:
    """Create feature directory if it doesn't exist and return the full path."""
    feature_dir = base_path / 'features' / feature_type
    feature_dir.mkdir(parents=True, exist_ok=True)
    return feature_dir / f"{paper_id}{ext}"

def process_pdf_grobid(
    pdf_path: str, 
    format: OutputFormat = 'markdown', 
    tag: str = "grobid",
    output_path: str | None = None,
    regenerate_tei: bool = True,
) -> None:
    """
    Process a PDF file using Grobid and convert to the specified format.
    
    Output files will be saved in feature-specific directories:
    - TEI XML files go to features/tei-xml-grobid/
    - Markdown files go to features/markdown-grobid/
    
    Args:
        pdf_path: Path to the PDF file relative to the repository root.
        format: Output format, either 'markdown' or 'tei'.
        tag: Optional tag to append to the output filename (default: "grobid").
        output_path: Optional path where the output file should be saved. If provided,
            this overrides the default feature directory behavior.
        regenerate_tei: Whether to regenerate TEI XML even if it exists.
    """
    pdf_path = Path(pdf_path)
    if not pdf_path.exists():
        raise FileNotFoundError(f"PDF file not found: {pdf_path}")

    # Get paper directory
    paper_dir = pdf_path.parent

    # Generate paper ID from PDF filename
    paper_id = pdf_path.stem

    # Determine output paths
    if output_path:
        output_path = Path(output_path)
        tei_path = output_path.with_suffix('.tei.xml')
        md_path = output_path.with_suffix('.md')
    else:
        # Use feature directory structure
        tei_path = get_feature_path(paper_dir, f'tei-xml-{tag}', paper_id, '.xml')
        md_path = get_feature_path(paper_dir, f'markdown-{tag}', paper_id, '.md')
    
    logger.info(f"Processing {pdf_path}")
    logger.info(f"TEI output will go to {tei_path}")
    logger.info(f"Markdown output will go to {md_path}")

    if regenerate_tei or (not tei_path.exists()):
        grobid_host = os.environ.get('GROBID_HOST', 'localhost')
        base_url = f"http://{grobid_host}:8070"
        
        # Call Grobid to process the PDF into TEI XML
        with open(pdf_path, 'rb') as f:
            files = {'input': (pdf_path.name, f, 'application/pdf')}
            resp = requests.post(
                f"{base_url}/api/processFulltextDocument",
                files=files,
                headers={'Accept': 'application/xml'},
                timeout=300  # 5 minute timeout
            )
        
        if resp.status_code != 200:
            raise RuntimeError(f"Grobid processing failed: {resp.status_code}")
        
        # Ensure the feature directory exists and save the TEI output
        tei_path.parent.mkdir(parents=True, exist_ok=True)
        tei_path.write_text(resp.text)
        logger.info(f"Saved TEI XML to {tei_path}")
    
    if format == 'markdown':
        # Convert TEI to Markdown using XSLT
        xslt_path = Path(__file__).parent / 'tei2md.xslt'
        if not xslt_path.exists():
            raise FileNotFoundError(f"XSLT stylesheet not found: {xslt_path}")
        
        xslt = etree.parse(str(xslt_path))
        transform = etree.XSLT(xslt)
        
        tei_doc = etree.parse(str(tei_path))
        markdown = str(transform(tei_doc))
        markdown = sanitize_markdown(markdown)
        
        # Ensure the feature directory exists and save Markdown output
        md_path.parent.mkdir(parents=True, exist_ok=True)
        md_path.write_text(markdown)
        logger.info(f"Saved Markdown to {md_path}")
    else:
        logger.info(f"Output TEI XML saved at {tei_path}")

process_pdf = process_pdf_grobid

# Files to ignore during operations
ignore_files = [
    "gh-store-snapshot.json",
    "papers-archive.json",
    "papers.json",
    "papers.yaml"
]

# def flush_old_conversions(data_path: str = "data/papers", tag: str = "grobid"):
#     """
#     Remove all previous conversions with the specified tag from feature directories.
#     """
#     base_path = Path(data_path).parent
#     tei_dir = base_path / 'features' / f'tei-xml-{tag}'
#     md_dir = base_path / 'features' / f'markdown-{tag}'
    
#     if tei_dir.exists():
#         for fpath in tei_dir.glob("*.xml"):
#             fpath.unlink()
#         tei_dir.rmdir()
    
#     if md_dir.exists():
#         for fpath in md_dir.glob("*.md"):
#             fpath.unlink()
#         md_dir.rmdir()

def generate_missing_conversions(
    data_path: str = "data/papers",
    tag: str = "grobid",
    checkpoint_cadence=5,
    regenerate_tei: bool = True,
):
    """
    Generate missing conversions for PDFs, saving outputs to feature directories.
    """
    data_path = Path(data_path)
    modified_files = []
    
    for i, pdf_fpath in enumerate(data_path.rglob("*.pdf")):
        # Skip PDFs in source directories
        if "source" in str(pdf_fpath):
            continue
            
        # Determine feature paths
        #base_dir = pdf_fpath.parent.parent
        paper_dir = pdf_fpath.parent
        paper_id = pdf_fpath.stem
        md_path = get_feature_path(paper_dir, f'markdown-{tag}', paper_id, '.md')
        
        if not md_path.exists():
            process_pdf_grobid(pdf_fpath, regenerate_tei=regenerate_tei)
            # Add both markdown and TEI paths
            tei_path = get_feature_path(paper_dir, f'tei-xml-{tag}', paper_id, '.xml')
            modified_files.extend([md_path, tei_path])
            logger.info(f"Generated conversions for {pdf_fpath.name}")
            
        if (i % checkpoint_cadence) == 0 and modified_files:
            msg = "Persisting feature conversions"
            commit_and_push(files_to_commit=modified_files, message=msg)
            modified_files = []
            
    if modified_files:
        commit_and_push(files_to_commit=modified_files, message="Persisting remaining feature conversions")

if __name__ == '__main__':
    fire.Fire({
        "process_pdf": process_pdf,
        "generate_missing_conversions": generate_missing_conversions,
        #"flush_old_conversions": flush_old_conversions,
    })


