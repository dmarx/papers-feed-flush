---
File: frontend/index.html
---
<!DOCTYPE html>
<!-- index.html - Root of GitHub Pages site -->
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DigThatData Papers Feed</title>
  
  <!-- Tabulator CSS and JS -->
  <link href="https://unpkg.com/tabulator-tables@6.3.0/dist/css/tabulator.min.css" rel="stylesheet">
  <script src="https://unpkg.com/tabulator-tables@6.3.0/dist/js/tabulator.min.js"></script>
  
  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <link rel="stylesheet" href="papersfeed.css">
</head>
<body>
  <div class="header">
    <div class="header-title">
        <h1>ArXiv Paper Feed</h1>
        <p class="header-desc">Papers recently visited by <a href="https://bsky.app/profile/digthatdata.bsky.social">@DigThatData</a></p>
    </div>

    <div class="controls">
      <div class="search-box">
        <input type="text" id="search-input" placeholder="Search papers by title, author, or content...">
      </div>
      <button class="filter-button" id="sidebar-toggle">
        <i class="fas fa-filter"></i> Filters
      </button>
    </div>
  </div>
  
  <div class="dashboard-container">
    <div class="main-content">
      <div id="papers-table">
        <div class="loading">Loading papers data...</div>
      </div>
    </div>
    
    <!-- Filter Sidebar -->
    <div class="sidebar" id="sidebar">
      <h3>Filters</h3>
      
      <div class="filter-section">
        <h4>Publication Date</h4>
        <div id="date-filter-controls">
          <div>
            <label for="date-filter-from">From:</label>
            <input type="date" id="date-filter-from">
          </div>
          <div style="margin-top: 10px;">
            <label for="date-filter-to">To:</label>
            <input type="date" id="date-filter-to">
          </div>
          <div style="margin-top: 15px;">
            <button id="apply-date-filter" class="filter-button">Apply</button>
            <button id="clear-date-filter" class="filter-button">Clear</button>
          </div>
        </div>
      </div>
      
      <div class="filter-section">
        <h4>Reading Status</h4>
        <div>
          <label>
            <input type="checkbox" id="filter-read" checked> Show Read Papers
          </label>
        </div>
        <div>
          <label>
            <input type="checkbox" id="filter-unread" checked> Show Unread Papers
          </label>
        </div>
      </div>
      
      <div class="filter-section">
        <h4>Reading Time</h4>
        <div>
          <label for="min-reading-time">Minimum (minutes):</label>
          <input type="number" id="min-reading-time" min="0" step="1">
        </div>
        <div style="margin-top: 10px;">
          <button id="apply-reading-filter" class="filter-button">Apply</button>
          <button id="clear-reading-filter" class="filter-button">Clear</button>
        </div>
      </div>
      
      <div class="filter-section">
        <h4>Interaction Days</h4>
        <div>
          <label for="min-interaction-days">Minimum days:</label>
          <input type="number" id="min-interaction-days" min="0" step="1">
        </div>
        <div style="margin-top: 10px;">
          <button id="apply-days-filter" class="filter-button">Apply</button>
          <button id="clear-days-filter" class="filter-button">Clear</button>
        </div>
      </div>
      
      <div class="filter-section">
        <h4>Reset All Filters</h4>
        <button id="reset-all-filters" class="filter-button">Reset All</button>
      </div>
    </div>
    
    <!-- Details Sidebar (new) -->
    <div class="sidebar" id="details-sidebar">
      <div id="details-content"></div>
    </div>
  </div>
  
  <button id="filter-toggle-btn" title="Toggle Filters">
    <i class="fas fa-filter"></i>
  </button>

  <script src="papersfeed.js"></script>
</body>
</html>



---
File: frontend/papersfeed.css
---
/* frontend/papersfeed.css */
body {
  margin: 0;
  padding: 0;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  background-color: #f5f7fa;
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}

.header {
  padding: 20px 20px 15px 20px;
  background-color: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
  z-index: 10;
}

h1 {
  margin: 0 0 10px 0;
  color: #333;
}

.controls {
  display: flex;
  gap: 10px;
  margin-bottom: 10px;
}

.search-box {
  flex-grow: 1;
}

#search-input {
  width: 100%;
  padding: 8px 12px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 16px;
}

.filter-button {
  padding: 8px 15px;
  background-color: #f0f0f0;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 5px;
}

.filter-button:hover {
  background-color: #e8e8e8;
}

.dashboard-container {
  display: flex;
  flex: 1;
  overflow: hidden;
  position: relative;
}

.main-content {
  flex: 1;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

#papers-table {
  flex: 1;
  width: 100%;
}

/* Shared sidebar styles */
.sidebar {
  background-color: white;
  box-shadow: -2px 0 5px rgba(0,0,0,0.1);
  overflow-y: auto;
  transition: all 0.3s ease;
  position: absolute;
  right: 0;
  top: 0;
  bottom: 0;
  width: 0;
  z-index: 100;
}

.sidebar.active {
  width: 400px;
  padding: 20px;
}

/* Filter sidebar specific */
#sidebar h3 {
  margin-top: 0;
  margin-bottom: 15px;
}

.filter-section {
  margin-bottom: 20px;
}

.filter-section h4 {
  margin-top: 0;
  margin-bottom: 10px;
  border-bottom: 1px solid #eee;
  padding-bottom: 5px;
}

/* Details sidebar specific */
#details-sidebar {
  z-index: 101; /* Higher than filter sidebar */
}

.details-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 20px;
}

.details-header h2 {
  margin: 0;
  flex: 1;
  line-height: 1.3;
}

.close-button {
  background: none;
  border: none;
  font-size: 20px;
  cursor: pointer;
  color: #666;
  padding: 0;
  margin-left: 15px;
}

.close-button:hover {
  color: #333;
}

.detail-section {
  margin-bottom: 25px;
  background-color: #f9f9f9;
  border-radius: 6px;
  padding: 15px;
}

.detail-section h3 {
  margin-top: 0;
  margin-bottom: 15px;
  color: #333;
  font-size: 1.1em;
  border-bottom: 1px solid #eee;
  padding-bottom: 8px;
}

.detail-table {
  width: 100%;
  border-collapse: collapse;
}

.detail-table th {
  text-align: left;
  padding: 8px;
  color: #666;
  font-weight: 600;
  width: 30%;
  vertical-align: top;
}

.detail-table td {
  padding: 8px;
  vertical-align: top;
}

.abstract-box {
  max-height: 300px;
  overflow-y: auto;
  padding: 15px;
  background-color: white;
  border-radius: 4px;
  line-height: 1.5;
  white-space: pre-line;
}

.tag {
  display: inline-block;
  background-color: #e8f0fe;
  padding: 3px 8px;
  margin: 2px;
  border-radius: 12px;
  font-size: 12px;
}

.loading {
  text-align: center;
  padding: 40px;
  font-size: 18px;
  color: #666;
}

.sessions-table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 10px;
}

.sessions-table th {
  background-color: #f2f2f2;
  padding: 8px;
  text-align: left;
}

.sessions-table td {
  padding: 8px;
  border-bottom: 1px solid #eee;
}

/* Toggle button for the sidebar */
#filter-toggle-btn {
  position: fixed;
  right: 20px;
  bottom: 20px;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background-color: #1a73e8;
  color: white;
  border: none;
  box-shadow: 0 2px 5px rgba(0,0,0,0.2);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  transition: background-color 0.3s;
  z-index: 102; /* Above both sidebars */
}

#filter-toggle-btn:hover {
  background-color: #1558b7;
}

/* Tabulator customizations */
.tabulator {
  border: none;
  background-color: transparent;
}

.tabulator-row {
  border-bottom: 1px solid #f0f0f0;
  cursor: pointer;
}

.tabulator-row:hover {
  background-color: #f2f8fd !important;
}

.tabulator-row.tabulator-row-even {
  background-color: #fafafa;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .sidebar.active {
    width: 85%;
  }
  
  .detail-grid {
    grid-template-columns: 1fr;
  }
}



---
File: frontend/papersfeed.js
---
// frontend/papersfeed.js
// Global variables
let table;
let allData = [];
let currentDetailsPaper = null;

// Format date to YYYY-MM-DD format
function formatDate(dateString) {
  if (!dateString) return '';
  const date = new Date(dateString);
  return date.toISOString().split('T')[0]; // YYYY-MM-DD format
}

// Format reading time from seconds to minutes
function formatReadingTime(seconds) {
  if (!seconds || seconds === 0) return 'Not read';
  const minutes = Math.round(seconds / 60);
  return minutes + (minutes === 1 ? ' minute' : ' minutes');
}

// Custom cell formatter for tags
function formatTags(cell) {
  const tags = cell.getValue();
  if (!tags || !Array.isArray(tags) || tags.length === 0) {
    return '';
  }
  
  return tags.map(tag => 
    `<span class="tag">${tag}</span>`
  ).join(' ');
}

// Format interactions for display
function formatInteractions(interactions) {
  if (!interactions || interactions.length === 0) {
    return '<p>No reading sessions recorded</p>';
  }
  
  return `
    <table class="sessions-table">
      <thead>
        <tr>
          <th>Date</th>
          <th>Duration</th>
          <th>Session ID</th>
        </tr>
      </thead>
      <tbody>
        ${interactions.map(interaction => {
          const date = new Date(interaction.timestamp);
          return `
            <tr>
              <td>${date.toLocaleString()}</td>
              <td>${interaction.data.duration_seconds} seconds</td>
              <td>${interaction.data.session_id}</td>
            </tr>
          `;
        }).join('')}
      </tbody>
    </table>
  `;
}

// Display paper details in the details sidebar
function displayPaperDetails(paperId) {
  console.log("Displaying details for paper ID:", paperId);
  
  // Find the paper data
  const paper = allData.find(p => p.paperKey === paperId);
  if (!paper) {
    console.error('Paper not found:', paperId);
    return;
  }
  
  // Update the current paper
  currentDetailsPaper = paper;
  
  // Get the details sidebar and content
  const detailsSidebar = document.getElementById('details-sidebar');
  const detailsContent = document.getElementById('details-content');
  
  // Update the content
  detailsContent.innerHTML = `
    <div class="details-header">
      <h2>${paper.title}</h2>
      <button id="close-details" class="close-button">
        <i class="fas fa-times"></i>
      </button>
    </div>
    
    <div class="detail-section">
      <h3>Paper Details</h3>
      <table class="detail-table">
        <tr>
          <th>ID:</th>
          <td>${paper.id}</td>
        </tr>
        <tr>
          <th>Authors:</th>
          <td>${paper.authors}</td>
        </tr>
        <tr>
          <th>Publication Date:</th>
          <td>${paper.published}</td>
        </tr>
        <tr>
          <th>Last Read:</th>
          <td>${paper.lastRead}</td>
        </tr>
        <tr>
          <th>Reading Time:</th>
          <td>${paper.readingTime}</td>
        </tr>
        <tr>
          <th>Interaction Days:</th>
          <td>${paper.interactionDays === 1 ? '1 day' : paper.interactionDays + ' days'}</td>
        </tr>
        <tr>
          <th>arXiv Tags:</th>
          <td>${formatTags({ getValue: () => paper.tags })}</td>
        </tr>
        <tr>
          <th>URL:</th>
          <td><a href="${paper.url}" target="_blank">${paper.url}</a></td>
        </tr>
      </table>
    </div>
    
    <div class="detail-section">
      <h3>Abstract</h3>
      <div class="abstract-box">
        ${paper.abstract}
      </div>
    </div>
    
    <div class="detail-section">
      <h3>Reading Sessions</h3>
      ${formatInteractions(paper.rawInteractionData)}
    </div>
  `;
  
  // Show the sidebar
  detailsSidebar.classList.add('active');
  
  // Set up close button
  const closeButton = document.getElementById('close-details');
  if (closeButton) {
    closeButton.addEventListener('click', function() {
      detailsSidebar.classList.remove('active');
    });
  }
}

function removePrefix(string, prefix, sep = ':') {
  if (string.startsWith(prefix + sep)) {
    return string.slice(prefix.length + sep.length);
  }
  return null; // Return null to indicate no match
}

function extractObjectId(string, prefix) {
  // Case 1: Format is "prefix:id"
  let result = removePrefix(string, prefix, ':');
  if (result !== null) return result;
  
  // Case 2: Format is "prefix.id"
  result = removePrefix(string, prefix, '.');
  if (result !== null) return result;
  
  // Case 3: Format is "prefix:prefix:id"
  result = removePrefix(string, prefix + ':' + prefix, ':');
  if (result !== null) return result;
  
  // Case 3 alternate: Format is "prefix.prefix.id"
  result = removePrefix(string, prefix + '.' + prefix, '.');
  if (result !== null) return result;
  
  // Case 4: If none of the above, return the original string
  return string;
}

function extractDomain(url) {
  try {
    const urlObj = new URL(url);
    return urlObj.hostname;
  } catch (error) {
    // Handle invalid URLs
    console.error("Invalid URL:", error);
    return null;
  }
}

// Process complex data structure
function processComplexData(data) {
  const result = [];
  const objects = data.objects;
  const paperKeys = Object.keys(objects).filter(key => key.startsWith("paper:"));
  
  for (const paperKey of paperKeys) {
    //const paperId = paperKey.split(":", 1)[1];
    const paperId = extractObjectId(paperKey, "paper");
    const paperRaw = objects[paperKey];
    const paperData = paperRaw.data;
    const paperMeta = paperRaw.meta;
    const interactionKey = `interactions:${paperId}`;
    const interactionData = objects[interactionKey] ? objects[interactionKey].data : null;
    
    // Calculate reading time
    let totalReadingTime = 0;
    let lastReadDate = null;
    
    // Calculate unique days with interactions
    let uniqueInteractionDays = 0;
    
    if (interactionData && interactionData.interactions) {
      const uniqueDays = new Set();
      
      for (const interaction of interactionData.interactions) {
        if (interaction.type === "reading_session") {
          totalReadingTime += interaction.data.duration_seconds || 0;
          
          // Find the most recent reading session
          const sessionDate = new Date(interaction.timestamp);
          if (!lastReadDate || sessionDate > lastReadDate) {
            lastReadDate = sessionDate;
          }
          
          // Track unique days
          if (interaction.timestamp) {
            const date = new Date(interaction.timestamp);
            const dateString = date.toISOString().split('T')[0]; // YYYY-MM-DD
            uniqueDays.add(dateString);
          }
        }
      }
      
      uniqueInteractionDays = uniqueDays.size;
    }

    const source = paperData.sourceId === 'arxiv' || paperData.sourceType === 'arxiv' ? 
               'arxiv' : (paperData.url ? extractDomain(paperData.url) : null) ||
                 paperData.sourceId || paperData.sourceType;
    
    // Create the row data
    result.push({
      paperKey: paperKey,
      id: paperId, //paperData.paper_id || paperData.arxivId,
      source: source,
      title: paperData.title,
      authors: paperData.authors,
      abstract: paperData.abstract,
      //published: paperData.publishedDate,  //formatDate(paperData.publishedDate) : '', //paperData.published_date || paperData.published || '',
      published: paperData.published_date ? formatDate(paperData.published_date) : '',
      firstRead: formatDate(paperMeta.created_at),
      lastRead: lastReadDate ? formatDate(lastReadDate) : formatDate(paperMeta.updated_at),
      readingTime: formatReadingTime(totalReadingTime),
      readingTimeSeconds: totalReadingTime,
      interactionDays: uniqueInteractionDays,
      tags: paperData.arxiv_tags || [],
      url: paperData.url,
      rawInteractionData: interactionData ? interactionData.interactions : [],
      hasBeenRead: lastReadDate !== null
    });
  }
  
  return result;
}

// Initialize the Tabulator table
function initTable(data) {
  table = new Tabulator("#papers-table", {
    data: data,
    layout: "fitColumns",
    responsiveLayout: "collapse",
    pagination: "local",
    paginationSize: 100,
    paginationSizeSelector: [10, 25, 50, 100, 500, 1000],
    movableColumns: true,
    groupBy: "lastRead",
    initialSort: [
      {column: "lastRead", dir: "desc"}
    ],
    columns: [
      {
        title: "ID", 
        field: "id", 
        widthGrow: 1
      },
      {
        title: "Source", 
        field: "source", 
        widthGrow: 1
      },
      {
        title: "Title", 
        field: "title", 
        widthGrow: 3,
        formatter: function(cell) {
          const value = cell.getValue();
          return value;
        }
      },
      {
        title: "Authors", 
        field: "authors", 
        widthGrow: 2
      },
      {
        title: "Published", 
        field: "published", 
        widthGrow: 1
      },
      {
        title: "First Read", 
        field: "firstRead", 
        widthGrow: 1
      },
      {
        title: "Last Read", 
        field: "lastRead", 
        widthGrow: 1
      },
      {
        title: "Reading Time", 
        field: "readingTimeSeconds", 
        widthGrow: 1,
        formatter: function(cell) {
          return cell.getRow().getData().readingTime;
        }
      },
      {
        title: "Days", 
        field: "interactionDays", 
        widthGrow: 1,
        formatter: function(cell) {
          const value = cell.getValue();
          if (value === 0) return "None";
          return value === 1 ? "1 day" : `${value} days`;
        }
      },
      {
        title: "Tags", 
        field: "tags", 
        widthGrow: 2,
        formatter: formatTags
      }
    ],
    rowFormatter: function(row) {
      // Add classes based on read status
      // if (row.getData().hasBeenRead) {
      //   row.getElement().classList.add("paper-read");
      // } else {
      //   row.getElement().classList.add("paper-unread");
      // }
      
      // Add paper ID as data attribute
      const rowElement = row.getElement();
      const paper_Id = row.getData().paperKey;
      //const paper_Id = row.getData("id");
      console.log("formatter detected paperId:", paper_Id);
      rowElement.setAttribute("data-paper-id", paper_Id);
    }
  });
  
  // Remove loading message
  document.querySelector(".loading").style.display = "none";
  
  // Set up global click handler for the table
  document.getElementById("papers-table").addEventListener("click", function(e) {
    // Find the closest row element
    const rowElement = e.target.closest(".tabulator-row");
    if (rowElement) {
      const paperId = rowElement.getAttribute("data-paper-id");
      console.log("detected click on row for paperId:", paperId);
      if (paperId) {
        displayPaperDetails(paperId);
      }
    }
  });
}

// Setup event listeners for filters and search
function setupEventListeners() {
  // Global search
  document.getElementById("search-input").addEventListener("input", function(e) {
    table.setFilter(function(data) {
      const searchTerm = e.target.value.toLowerCase();
      if (!searchTerm) return true;
      
      // Search in title, authors, abstract, and tags
      return (
        data.title.toLowerCase().includes(searchTerm) ||
        data.authors.toLowerCase().includes(searchTerm) ||
        data.abstract.toLowerCase().includes(searchTerm) ||
        (data.tags && data.tags.some(tag => tag.toLowerCase().includes(searchTerm)))
      );
    });
  });
  
  // Toggle filter sidebar
  document.getElementById("sidebar-toggle").addEventListener("click", function() {
    document.getElementById("sidebar").classList.toggle("active");
    
    // Close details sidebar if open (to avoid both being open at once)
    document.getElementById("details-sidebar").classList.remove("active");
  });
  
  // Floating filter button
  document.getElementById("filter-toggle-btn").addEventListener("click", function() {
    document.getElementById("sidebar").classList.toggle("active");
    
    // Close details sidebar if open (to avoid both being open at once)
    document.getElementById("details-sidebar").classList.remove("active");
  });
  
  // Toggle details with keyboard escape key
  document.addEventListener("keydown", function(e) {
    if (e.key === "Escape") {
      document.getElementById("details-sidebar").classList.remove("active");
      document.getElementById("sidebar").classList.remove("active");
    }
  });
  
  // Date filter
  document.getElementById("apply-date-filter").addEventListener("click", function() {
    const fromDate = document.getElementById("date-filter-from").value;
    const toDate = document.getElementById("date-filter-to").value;
    
    table.setFilter(function(data) {
      if (!fromDate && !toDate) return true;
      if (!data.published) return false;
      
      if (fromDate && toDate) {
        return data.published >= fromDate && data.published <= toDate;
      }
      
      if (fromDate) {
        return data.published >= fromDate;
      }
      
      if (toDate) {
        return data.published <= toDate;
      }
      
      return true;
    });
  });
  
  document.getElementById("clear-date-filter").addEventListener("click", function() {
    document.getElementById("date-filter-from").value = "";
    document.getElementById("date-filter-to").value = "";
    table.clearFilter();
  });
  
  // Read/Unread filters
  function updateReadFilter() {
    const showRead = document.getElementById("filter-read").checked;
    const showUnread = document.getElementById("filter-unread").checked;
    
    if (showRead && showUnread) {
      table.removeFilter("hasBeenRead");
      return;
    }
    
    if (showRead) {
      table.setFilter("hasBeenRead", "=", true);
      return;
    }
    
    if (showUnread) {
      table.setFilter("hasBeenRead", "=", false);
      return;
    }
    
    // If neither is checked, show nothing
    table.setFilter(function() { return false; });
  }
  
  document.getElementById("filter-read").addEventListener("change", updateReadFilter);
  document.getElementById("filter-unread").addEventListener("change", updateReadFilter);
  
  // Reading time filter
  document.getElementById("apply-reading-filter").addEventListener("click", function() {
    const minReading = document.getElementById("min-reading-time").value;
    
    if (!minReading) {
      table.removeFilter("readingTimeSeconds");
      return;
    }
    
    const minSeconds = parseInt(minReading) * 60;
    table.setFilter("readingTimeSeconds", ">=", minSeconds);
  });
  
  document.getElementById("clear-reading-filter").addEventListener("click", function() {
    document.getElementById("min-reading-time").value = "";
    table.removeFilter("readingTimeSeconds");
  });
  
  // Interaction days filter
  document.getElementById("apply-days-filter").addEventListener("click", function() {
    const minDays = document.getElementById("min-interaction-days").value;
    
    if (!minDays) {
      table.removeFilter("interactionDays");
      return;
    }
    
    table.setFilter("interactionDays", ">=", parseInt(minDays));
  });
  
  document.getElementById("clear-days-filter").addEventListener("click", function() {
    document.getElementById("min-interaction-days").value = "";
    table.removeFilter("interactionDays");
  });
  
  // Reset all filters
  document.getElementById("reset-all-filters").addEventListener("click", function() {
    // Clear all input fields
    document.getElementById("search-input").value = "";
    document.getElementById("date-filter-from").value = "";
    document.getElementById("date-filter-to").value = "";
    document.getElementById("min-reading-time").value = "";
    document.getElementById("min-interaction-days").value = "";
    
    // Reset checkboxes
    document.getElementById("filter-read").checked = true;
    document.getElementById("filter-unread").checked = true;
    
    // Clear all table filters
    table.clearFilter();
  });
}

// Load and initialize
document.addEventListener("DOMContentLoaded", function() {
  // Fetch data file
  fetch("gh-store-snapshot.json")
    .then(response => {
      if (!response.ok) {
        throw new Error("Failed to load data.json");
      }
      return response.json();
    })
    .then(data => {
      allData = processComplexData(data);
      initTable(allData);
      setupEventListeners();
    })
    .catch(error => {
      document.querySelector(".loading").innerHTML = 
        `Error loading data: ${error.message}. Make sure data.json exists in the same directory as this HTML file.`;
    });
});


